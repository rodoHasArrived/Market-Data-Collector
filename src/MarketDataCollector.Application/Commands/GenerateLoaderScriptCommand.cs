using MarketDataCollector.Application.ResultTypes;

namespace MarketDataCollector.Application.Commands;

/// <summary>
/// CLI command to generate Python or R loader scripts for exported market data.
/// Implements improvement 10.3 from the high-value improvements brainstorm.
///
/// Usage:
///   --generate-loader python --data-dir ./data/exports
///   --generate-loader r --data-dir ./data/exports --format csv
/// </summary>
internal sealed class GenerateLoaderScriptCommand : ICliCommand
{
    private const string Flag = "--generate-loader";

    public bool CanHandle(string[] args) => CliArguments.HasFlag(args, Flag);

    public Task<CliResult> ExecuteAsync(string[] args, CancellationToken ct = default)
    {
        var language = CliArguments.GetValue(args, Flag) ?? "python";
        var dataDir = CliArguments.GetValue(args, "--data-dir") ?? ".";
        var format = CliArguments.GetValue(args, "--format") ?? "parquet";
        var outputFile = CliArguments.GetValue(args, "--output");

        var script = language.ToLowerInvariant() switch
        {
            "python" or "py" => GeneratePythonScript(dataDir, format),
            "r" => GenerateRScript(dataDir, format),
            _ => null
        };

        if (script is null)
        {
            Console.Error.WriteLine($"Unsupported language: {language}. Use 'python' or 'r'.");
            return Task.FromResult(CliResult.Fail(ErrorCode.ValidationError));
        }

        if (outputFile is not null)
        {
            var dir = Path.GetDirectoryName(outputFile);
            if (!string.IsNullOrEmpty(dir))
                Directory.CreateDirectory(dir);

            File.WriteAllText(outputFile, script);
            Console.WriteLine($"Loader script written to: {outputFile}");
        }
        else
        {
            // Default output filename
            var defaultName = language.ToLowerInvariant() switch
            {
                "r" => "load_data.R",
                _ => "load_data.py"
            };
            var outPath = Path.Combine(dataDir, defaultName);
            File.WriteAllText(outPath, script);
            Console.WriteLine($"Loader script written to: {outPath}");
        }

        return Task.FromResult(CliResult.Ok());
    }

    private static string GeneratePythonScript(string dataDir, string format)
    {
        var readFunc = format.ToLowerInvariant() switch
        {
            "parquet" => "pd.read_parquet(f)",
            "csv" => "pd.read_csv(f, parse_dates=['Timestamp'])",
            "jsonl" => "pd.read_json(f, lines=True)",
            _ => "pd.read_parquet(f)"
        };
        var ext = format.ToLowerInvariant() switch
        {
            "parquet" => "parquet",
            "csv" => "csv",
            "jsonl" => "jsonl",
            _ => "parquet"
        };

        return $$"""
            #!/usr/bin/env python3
            """
            + "\"\"\"\n"
            + "Market Data Loader\n"
            + "Generated by: MarketDataCollector --generate-loader python\n"
            + "\n"
            + "Usage:\n"
            + "    from load_data import load_trades, load_quotes\n"
            + "    trades = load_trades('AAPL')\n"
            + "    quotes = load_quotes()\n"
            + "\"\"\"\n"
            + $$"""

            import pandas as pd
            from pathlib import Path
            from typing import Optional

            DATA_DIR = Path("{{dataDir}}")


            def load_data(
                symbol: Optional[str] = None,
                event_type: str = "trade",
                start_date: Optional[str] = None,
                end_date: Optional[str] = None,
            ) -> pd.DataFrame:
                """Load market data into a pandas DataFrame.

                Args:
                    symbol: Filter by ticker symbol (e.g., 'AAPL'). None loads all symbols.
                    event_type: Event type ('trade', 'quote', 'depth', 'bar').
                    start_date: Filter start date (YYYY-MM-DD).
                    end_date: Filter end date (YYYY-MM-DD).

                Returns:
                    DataFrame with market data.
                """
                if symbol:
                    pattern = f"{symbol}*{event_type}*.{{ext}}"
                else:
                    pattern = f"*{event_type}*.{{ext}}"

                files = sorted(DATA_DIR.rglob(pattern))
                if not files:
                    # Try without event_type filter
                    pattern = f"{symbol}*.{{ext}}" if symbol else f"*.{{ext}}"
                    files = sorted(DATA_DIR.rglob(pattern))

                if not files:
                    raise FileNotFoundError(
                        f"No {{ext}} files found in {DATA_DIR}. "
                        f"Pattern: {pattern}"
                    )

                dfs = [{{readFunc}} for f in files]
                df = pd.concat(dfs, ignore_index=True)

                # Apply date filtering if timestamps are available
                if "Timestamp" in df.columns:
                    df["Timestamp"] = pd.to_datetime(df["Timestamp"])
                    if start_date:
                        df = df[df["Timestamp"] >= start_date]
                    if end_date:
                        df = df[df["Timestamp"] <= end_date]

                return df.sort_values("Timestamp") if "Timestamp" in df.columns else df


            def load_trades(symbol: Optional[str] = None, **kwargs) -> pd.DataFrame:
                """Load trade data."""
                return load_data(symbol, "trade", **kwargs)


            def load_quotes(symbol: Optional[str] = None, **kwargs) -> pd.DataFrame:
                """Load quote/BBO data."""
                return load_data(symbol, "quote", **kwargs)


            def load_bars(symbol: Optional[str] = None, **kwargs) -> pd.DataFrame:
                """Load historical bar data."""
                return load_data(symbol, "bar", **kwargs)


            def summary() -> None:
                """Print a summary of available data."""
                all_files = list(DATA_DIR.rglob("*.{{ext}}"))
                print(f"Data directory: {DATA_DIR}")
                print(f"Total files: {len(all_files)}")
                total_size = sum(f.stat().st_size for f in all_files)
                print(f"Total size: {total_size / 1024 / 1024:.1f} MB")

                symbols = set()
                for f in all_files:
                    parts = f.stem.split(".")
                    if parts:
                        symbols.add(parts[0])
                print(f"Symbols: {sorted(symbols)}")


            if __name__ == "__main__":
                summary()
                print()
                try:
                    df = load_trades()
                    print(f"Loaded {len(df):,} trade records")
                    print(df.head())
                except FileNotFoundError as e:
                    print(f"No data found: {e}")
            """;
    }

    private static string GenerateRScript(string dataDir, string format)
    {
        var readFunc = format.ToLowerInvariant() switch
        {
            "csv" => "read_csv(f, show_col_types = FALSE)",
            "parquet" => "arrow::read_parquet(f)",
            _ => "read_csv(f, show_col_types = FALSE)"
        };
        var ext = format.ToLowerInvariant() switch
        {
            "parquet" => "parquet",
            "csv" => "csv",
            _ => "csv"
        };

        return $"""
            # Market Data Loader
            # Generated by: MarketDataCollector --generate-loader r
            #
            # Usage:
            #   source("load_data.R")
            #   trades <- load_trades("AAPL")
            #   quotes <- load_quotes()

            library(tidyverse)
            library(lubridate)

            DATA_DIR <- "{dataDir}"

            #' Load market data from exported files.
            #'
            #' @param symbol Optional symbol filter (e.g., "AAPL")
            #' @param event_type Event type: "trade", "quote", "bar"
            #' @param start_date Optional start date filter (Date or string)
            #' @param end_date Optional end date filter (Date or string)
            #' @return A tibble with market data
            load_data <- function(symbol = NULL, event_type = "trade",
                                  start_date = NULL, end_date = NULL) {{
              if (!is.null(symbol)) {{
                pattern <- paste0(symbol, ".*", event_type, ".*\\.{ext}$")
              }} else {{
                pattern <- paste0(".*", event_type, ".*\\.{ext}$")
              }}

              files <- list.files(DATA_DIR, pattern = pattern,
                                  full.names = TRUE, recursive = TRUE)

              if (length(files) == 0) {{
                # Try without event_type
                pattern <- if (!is.null(symbol)) {{
                  paste0(symbol, ".*\\.{ext}$")
                }} else {{
                  paste0(".*\\.{ext}$")
                }}
                files <- list.files(DATA_DIR, pattern = pattern,
                                    full.names = TRUE, recursive = TRUE)
              }}

              if (length(files) == 0) {{
                stop(paste("No {ext} files found in", DATA_DIR))
              }}

              df <- files %>%
                map_dfr(~{readFunc})

              # Parse timestamps and apply date filters
              if ("Timestamp" %in% names(df)) {{
                df <- df %>% mutate(Timestamp = ymd_hms(Timestamp))
                if (!is.null(start_date)) {{
                  df <- df %>% filter(Timestamp >= ymd(start_date))
                }}
                if (!is.null(end_date)) {{
                  df <- df %>% filter(Timestamp <= ymd(end_date))
                }}
                df <- df %>% arrange(Timestamp)
              }}

              return(df)
            }}

            load_trades <- function(symbol = NULL, ...) load_data(symbol, "trade", ...)
            load_quotes <- function(symbol = NULL, ...) load_data(symbol, "quote", ...)
            load_bars <- function(symbol = NULL, ...) load_data(symbol, "bar", ...)

            summary_data <- function() {{
              files <- list.files(DATA_DIR, pattern = "\\.{ext}$",
                                  full.names = TRUE, recursive = TRUE)
              cat("Data directory:", DATA_DIR, "\n")
              cat("Total files:", length(files), "\n")
              total_size <- sum(file.info(files)$size) / 1024 / 1024
              cat("Total size:", round(total_size, 1), "MB\n")
            }}
            """;
    }
}
