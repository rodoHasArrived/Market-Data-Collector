using System.Collections.Concurrent;
using System.Threading;
using MarketDataCollector.Application.Exceptions;
using MarketDataCollector.Application.Logging;
using MarketDataCollector.Contracts.Domain.Models;
using MarketDataCollector.Domain.Models;
using MarketDataCollector.Infrastructure.Contracts;
using MarketDataCollector.Infrastructure.Providers.Backfill.SymbolResolution;
using Serilog;

namespace MarketDataCollector.Infrastructure.Providers.Backfill;

/// <summary>
/// Composite provider that chains multiple data providers with automatic failover.
/// Supports symbol resolution, provider health tracking, rate-limit aware rotation,
/// and cross-provider validation.
/// </summary>
[ImplementsAdr("ADR-001", "Composite historical data provider with failover")]
[ImplementsAdr("ADR-004", "All async methods support CancellationToken")]
public sealed class CompositeHistoricalDataProvider : IHistoricalDataProvider, IDisposable
{
    private readonly List<IHistoricalDataProvider> _providers;
    private readonly ISymbolResolver? _symbolResolver;
    private readonly ProviderRateLimitTracker _rateLimitTracker;
    private readonly ConcurrentDictionary<string, ProviderHealthStatus> _healthStatus = new();
    private readonly ConcurrentDictionary<string, DateTimeOffset> _providerFailures = new();
    private readonly TimeSpan _failureBackoffDuration;
    private readonly bool _enableCrossValidation;
    private readonly bool _enableRateLimitRotation;
    private readonly double _rateLimitRotationThreshold;
    private readonly ILogger _log;
    private bool _disposed;

    /// <summary>
    /// Event raised when progress is updated during backfill.
    /// </summary>
#pragma warning disable CS0067 // Event is never used - Reserved for future extensibility
    public event Action<ProviderBackfillProgress>? OnProgressUpdate;
#pragma warning restore CS0067

    public string Name => "composite";
    public string DisplayName => "Multi-Source (Auto-Failover)";
    public string Description => $"Automatically tries multiple providers ({string.Join(", ", _providers.Select(p => p.Name))}) with failover support.";

    public int Priority => 0;
    public TimeSpan RateLimitDelay => TimeSpan.Zero;
    public int MaxRequestsPerWindow => int.MaxValue;
    public TimeSpan RateLimitWindow => TimeSpan.FromHours(1);

    /// <summary>
    /// Aggregated capabilities from all child providers.
    /// A capability is supported if ANY child provider supports it.
    /// </summary>
    public HistoricalDataCapabilities Capabilities => new()
    {
        AdjustedPrices = _providers.Any(p => p.Capabilities.AdjustedPrices),
        Intraday = _providers.Any(p => p.Capabilities.Intraday),
        Dividends = _providers.Any(p => p.Capabilities.Dividends),
        Splits = _providers.Any(p => p.Capabilities.Splits),
        Quotes = _providers.Any(p => p.Capabilities.Quotes),
        Trades = _providers.Any(p => p.Capabilities.Trades),
        Auctions = _providers.Any(p => p.Capabilities.Auctions),
        SupportedMarkets = _providers
            .SelectMany(p => p.Capabilities.SupportedMarkets)
            .Distinct()
            .ToList()
    };

    /// <summary>
    /// Get current health status of all providers.
    /// </summary>
    public IReadOnlyDictionary<string, ProviderHealthStatus> ProviderHealth => _healthStatus;

    /// <summary>
    /// Get current rate limit status for all providers.
    /// </summary>
    public IReadOnlyDictionary<string, RateLimitStatus> RateLimitStatus => _rateLimitTracker.GetAllStatus();

    public CompositeHistoricalDataProvider(
        IEnumerable<IHistoricalDataProvider> providers,
        ISymbolResolver? symbolResolver = null,
        TimeSpan? failureBackoffDuration = null,
        bool enableCrossValidation = false,
        bool enableRateLimitRotation = true,
        double rateLimitRotationThreshold = 0.8,
        ILogger? log = null)
    {
        _providers = providers
            .OrderBy(p => p.Priority)
            .ToList();

        if (_providers.Count == 0)
            throw new ArgumentException("At least one provider is required", nameof(providers));

        _symbolResolver = symbolResolver;
        _failureBackoffDuration = failureBackoffDuration ?? TimeSpan.FromMinutes(5);
        _enableCrossValidation = enableCrossValidation;
        _enableRateLimitRotation = enableRateLimitRotation;
        _rateLimitRotationThreshold = rateLimitRotationThreshold;
        _log = log ?? LoggingSetup.ForContext<CompositeHistoricalDataProvider>();

        // Initialize rate limit tracker
        _rateLimitTracker = new ProviderRateLimitTracker(_log);
        foreach (var provider in _providers)
        {
            _rateLimitTracker.RegisterProvider(provider);
        }

        // Initialize health status
        foreach (var provider in _providers)
        {
            _healthStatus[provider.Name] = new ProviderHealthStatus(provider.Name, true, "Not checked");
        }
    }

    public async Task<bool> IsAvailableAsync(CancellationToken ct = default)
    {
        // Available if any provider is available
        foreach (var provider in _providers)
        {
            if (await provider.IsAvailableAsync(ct).ConfigureAwait(false))
                return true;
        }
        return false;
    }

    public async Task<IReadOnlyList<HistoricalBar>> GetDailyBarsAsync(string symbol, DateOnly? from, DateOnly? to, CancellationToken ct = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        if (string.IsNullOrWhiteSpace(symbol))
            throw new ArgumentException("Symbol is required", nameof(symbol));

        List<(string Provider, Exception Error)> errors = [];

        // Get providers ordered by rate limit availability if rotation is enabled
        var orderedProviders = GetOrderedProviders();

        foreach (var provider in orderedProviders)
        {
            // Skip providers in backoff period
            if (IsInBackoffPeriod(provider.Name))
            {
                _log.Debug("Skipping {Provider} - in backoff period", provider.Name);
                continue;
            }

            // Skip rate-limited providers if rotation is enabled
            if (_enableRateLimitRotation && _rateLimitTracker.IsRateLimited(provider.Name))
            {
                var resetTime = _rateLimitTracker.GetTimeUntilReset(provider.Name);
                _log.Debug("Skipping {Provider} - rate limited, resets in {ResetTime}", provider.Name, resetTime);
                continue;
            }

            try
            {
                // Resolve symbol for this provider if resolver is available
                var resolvedSymbol = await ResolveSymbolForProviderAsync(symbol, provider.Name, ct).ConfigureAwait(false);

                _log.Information("Trying {Provider} for {Symbol} (resolved: {Resolved})",
                    provider.Name, symbol, resolvedSymbol);

                var startTime = DateTimeOffset.UtcNow;

                // Record the request attempt
                _rateLimitTracker.RecordRequest(provider.Name);

                var bars = await provider.GetDailyBarsAsync(resolvedSymbol, from, to, ct).ConfigureAwait(false);
                var elapsed = DateTimeOffset.UtcNow - startTime;

                if (bars.Count > 0)
                {
                    // Update health status and clear any rate limit state
                    UpdateHealthStatus(provider.Name, true, $"Retrieved {bars.Count} bars", elapsed);
                    ClearFailure(provider.Name);
                    _rateLimitTracker.ClearRateLimitState(provider.Name);

                    _log.Information("Successfully retrieved {Count} bars from {Provider} for {Symbol}",
                        bars.Count, provider.Name, symbol);

                    // Optionally validate against other providers
                    if (_enableCrossValidation && bars.Count > 0)
                    {
                        await ValidateBarsAsync(bars, symbol, from, to, provider.Name, ct).ConfigureAwait(false);
                    }

                    return bars;
                }

                _log.Debug("No bars returned from {Provider} for {Symbol}, trying next", provider.Name, symbol);
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (Exception ex)
            {
                // Check if this is a rate limit error
                if (IsRateLimitException(ex))
                {
                    var retryAfter = ExtractRetryAfter(ex);
                    _rateLimitTracker.RecordRateLimitHit(provider.Name, retryAfter);
                    _log.Warning("Provider {Provider} hit rate limit for {Symbol}, rotating to next provider",
                        provider.Name, symbol);
                }
                else
                {
                    _log.Warning(ex, "Provider {Provider} failed for {Symbol}", provider.Name, symbol);
                    RecordFailure(provider.Name, ex.Message);
                }
                errors.Add((provider.Name, ex));
            }
        }

        // All providers failed - check if any are just rate limited and we should wait
        if (_enableRateLimitRotation && errors.All(e => IsRateLimitException(e.Error)))
        {
            var shortestWait = GetShortestRateLimitWait();
            if (shortestWait.HasValue && shortestWait.Value < TimeSpan.FromMinutes(5))
            {
                _log.Information("All providers rate limited. Waiting {WaitTime} for rate limit reset...",
                    shortestWait.Value);
                await Task.Delay(shortestWait.Value, ct).ConfigureAwait(false);

                // Retry after waiting
                return await GetDailyBarsAsync(symbol, from, to, ct).ConfigureAwait(false);
            }
        }

        // All providers failed
        if (errors.Count > 0)
        {
            var errorSummary = string.Join("; ", errors.Select(e => $"{e.Provider}: {e.Error.Message}"));
            throw new AggregateException($"All providers failed for {symbol}: {errorSummary}",
                errors.Select(e => e.Error));
        }

        _log.Warning("No data found from any provider for {Symbol}", symbol);
        return Array.Empty<HistoricalBar>();
    }

    /// <summary>
    /// Get providers ordered by rate limit capacity when rotation is enabled.
    /// </summary>
    private IEnumerable<IHistoricalDataProvider> GetOrderedProviders()
    {
        if (!_enableRateLimitRotation)
            return _providers;

        // Order by: not rate limited first, then by usage ratio (lowest first), then by priority
        return _providers.OrderBy(p =>
        {
            if (_rateLimitTracker.IsRateLimited(p.Name))
                return 1000; // Put rate-limited providers last

            if (_rateLimitTracker.IsApproachingLimit(p.Name, _rateLimitRotationThreshold))
                return 100 + (int)(_rateLimitTracker.GetStatus(p.Name)?.UsagePercent ?? 0);

            return p.Priority;
        });
    }

    /// <summary>
    /// Check if an exception indicates a rate limit error (HTTP 429).
    /// Supports both the strongly-typed RateLimitException and legacy string-based detection.
    /// </summary>
    private static bool IsRateLimitException(Exception ex) =>
        ex is RateLimitException ||
        ex.InnerException is RateLimitException ||
        ex.Message.Contains("429") ||
        ex.Message.Contains("rate limit", StringComparison.OrdinalIgnoreCase) ||
        ex.Message.Contains("too many requests", StringComparison.OrdinalIgnoreCase);

    /// <summary>
    /// Extract Retry-After duration from an exception if available.
    /// Supports both RateLimitException with structured data and legacy string parsing.
    /// </summary>
    private static TimeSpan? ExtractRetryAfter(Exception ex)
    {
        // Check for strongly-typed RateLimitException first
        if (ex is RateLimitException rle && rle.RetryAfter.HasValue)
            return rle.RetryAfter;

        // Check inner exception
        if (ex.InnerException is RateLimitException innerRle && innerRle.RetryAfter.HasValue)
            return innerRle.RetryAfter;

        // Fall back to string-based parsing for backwards compatibility
        // Try to parse Retry-After from exception message
        // Format: "Retry-After: 60" or similar
        var message = ex.Message;
        var retryAfterIdx = message.IndexOf("retry-after", StringComparison.OrdinalIgnoreCase);
        if (retryAfterIdx >= 0)
        {
            var remaining = message[(retryAfterIdx + 12)..];
            var match = System.Text.RegularExpressions.Regex.Match(remaining, @"(\d+)");
            if (match.Success && int.TryParse(match.Groups[1].Value, out var seconds))
            {
                return TimeSpan.FromSeconds(seconds);
            }
        }
        return null;
    }

    /// <summary>
    /// Get the shortest wait time until any provider's rate limit resets.
    /// </summary>
    private TimeSpan? GetShortestRateLimitWait() =>
        _providers
            .Select(p => _rateLimitTracker.GetTimeUntilReset(p.Name))
            .Where(w => w.HasValue)
            .Min();

    public async Task<IReadOnlyList<AdjustedHistoricalBar>> GetAdjustedDailyBarsAsync(string symbol, DateOnly? from, DateOnly? to, CancellationToken ct = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        // Get providers that support adjusted prices, ordered by rate limit availability
        var adjustedProviders = _providers.Where(p => p.Capabilities.AdjustedPrices);

        if (_enableRateLimitRotation)
        {
            adjustedProviders = adjustedProviders.OrderBy(p =>
            {
                if (_rateLimitTracker.IsRateLimited(p.Name)) return 1000;
                if (_rateLimitTracker.IsApproachingLimit(p.Name, _rateLimitRotationThreshold))
                    return 100 + (int)(_rateLimitTracker.GetStatus(p.Name)?.UsagePercent ?? 0);
                return p.Priority;
            });
        }

        foreach (var provider in adjustedProviders)
        {
            if (IsInBackoffPeriod(provider.Name))
                continue;

            // Skip rate-limited providers if rotation is enabled
            if (_enableRateLimitRotation && _rateLimitTracker.IsRateLimited(provider.Name))
            {
                _log.Debug("Skipping {Provider} for adjusted bars - rate limited", provider.Name);
                continue;
            }

            try
            {
                var resolvedSymbol = await ResolveSymbolForProviderAsync(symbol, provider.Name, ct).ConfigureAwait(false);

                // Record the request attempt
                _rateLimitTracker.RecordRequest(provider.Name);

                var bars = await provider.GetAdjustedDailyBarsAsync(resolvedSymbol, from, to, ct).ConfigureAwait(false);

                if (bars.Count > 0)
                {
                    ClearFailure(provider.Name);
                    _rateLimitTracker.ClearRateLimitState(provider.Name);
                    return bars;
                }
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (Exception ex)
            {
                if (IsRateLimitException(ex))
                {
                    var retryAfter = ExtractRetryAfter(ex);
                    _rateLimitTracker.RecordRateLimitHit(provider.Name, retryAfter);
                    _log.Warning("Provider {Provider} hit rate limit for adjusted bars, rotating to next",
                        provider.Name);
                }
                else
                {
                    _log.Warning(ex, "Provider {Provider} failed for adjusted bars", provider.Name);
                    RecordFailure(provider.Name, ex.Message);
                }
            }
        }

        // Fallback to standard bars
        var standardBars = await GetDailyBarsAsync(symbol, from, to, ct).ConfigureAwait(false);
        return standardBars.Select(b => new AdjustedHistoricalBar(
            b.Symbol, b.SessionDate, b.Open, b.High, b.Low, b.Close, b.Volume, b.Source, b.SequenceNumber
        )).ToList();
    }

    /// <summary>
    /// Check health of all providers.
    /// </summary>
    public async Task<IReadOnlyDictionary<string, ProviderHealthStatus>> CheckAllProvidersHealthAsync(CancellationToken ct = default)
    {
        var tasks = _providers.Select(async p =>
        {
            var startTime = DateTimeOffset.UtcNow;
            try
            {
                var available = await p.IsAvailableAsync(ct).ConfigureAwait(false);
                var elapsed = DateTimeOffset.UtcNow - startTime;
                UpdateHealthStatus(p.Name, available, available ? "Healthy" : "Unavailable", elapsed);
            }
            catch (Exception ex)
            {
                UpdateHealthStatus(p.Name, false, ex.Message);
            }
        });

        await Task.WhenAll(tasks).ConfigureAwait(false);
        return _healthStatus;
    }

    private async Task<string> ResolveSymbolForProviderAsync(string symbol, string providerName, CancellationToken ct)
    {
        if (_symbolResolver is null)
            return symbol;

        try
        {
            var mapped = await _symbolResolver.MapSymbolAsync(symbol, "input", providerName, ct).ConfigureAwait(false);
            return mapped ?? symbol;
        }
        catch (Exception ex)
        {
            _log.Debug(ex, "Symbol resolution failed for {Symbol} -> {Provider}", symbol, providerName);
            return symbol;
        }
    }

    private async Task ValidateBarsAsync(IReadOnlyList<HistoricalBar> bars, string symbol, DateOnly? from, DateOnly? to, string sourceProvider, CancellationToken ct)
    {
        // Try to validate with a different provider
        var validationProvider = _providers.FirstOrDefault(p => p.Name != sourceProvider);
        if (validationProvider is null) return;

        try
        {
            var validationBars = await validationProvider.GetDailyBarsAsync(symbol, from, to, ct).ConfigureAwait(false);

            if (validationBars.Count > 0)
            {
                var discrepancies = 0;
                foreach (var bar in bars.Take(5)) // Check first 5 bars
                {
                    var matchingBar = validationBars.FirstOrDefault(b => b.SessionDate == bar.SessionDate);
                    if (matchingBar is not null)
                    {
                        var closeDiff = Math.Abs(bar.Close - matchingBar.Close) / bar.Close;
                        if (closeDiff > 0.01m) // More than 1% difference
                        {
                            discrepancies++;
                            _log.Debug("Price discrepancy on {Date}: {Provider1}={Price1}, {Provider2}={Price2}",
                                bar.SessionDate, sourceProvider, bar.Close, validationProvider.Name, matchingBar.Close);
                        }
                    }
                }

                if (discrepancies > 0)
                {
                    _log.Warning("Found {Count} price discrepancies between {Provider1} and {Provider2} for {Symbol}",
                        discrepancies, sourceProvider, validationProvider.Name, symbol);
                }
            }
        }
        catch (Exception ex)
        {
            _log.Debug(ex, "Cross-validation failed for {Symbol}", symbol);
        }
    }

    private bool IsInBackoffPeriod(string providerName)
    {
        if (_providerFailures.TryGetValue(providerName, out var failedAt))
        {
            return DateTimeOffset.UtcNow - failedAt < _failureBackoffDuration;
        }
        return false;
    }

    private void RecordFailure(string providerName, string message)
    {
        _providerFailures[providerName] = DateTimeOffset.UtcNow;
        UpdateHealthStatus(providerName, false, message);
    }

    private void ClearFailure(string providerName)
    {
        _providerFailures.TryRemove(providerName, out _);
    }

    private void UpdateHealthStatus(string providerName, bool isAvailable, string? message = null, TimeSpan? responseTime = null)
    {
        _healthStatus[providerName] = new ProviderHealthStatus(
            providerName,
            isAvailable,
            message,
            DateTimeOffset.UtcNow,
            responseTime
        );
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _rateLimitTracker.Dispose();

        foreach (var provider in _providers.OfType<IDisposable>())
        {
            provider.Dispose();
        }
    }
}

/// <summary>
/// Configuration for composite provider behavior.
/// </summary>
public sealed record CompositeProviderOptions
{
    /// <summary>
    /// Duration to skip a provider after failure.
    /// </summary>
    public TimeSpan FailureBackoffDuration { get; init; } = TimeSpan.FromMinutes(5);

    /// <summary>
    /// Enable cross-validation of data between providers.
    /// </summary>
    public bool EnableCrossValidation { get; init; } = false;

    /// <summary>
    /// Maximum number of retries per provider.
    /// </summary>
    public int MaxRetriesPerProvider { get; init; } = 2;

    /// <summary>
    /// Prefer providers that support adjusted prices.
    /// </summary>
    public bool PreferAdjustedPrices { get; init; } = true;

    /// <summary>
    /// Enable rate-limit aware provider rotation.
    /// When enabled, providers approaching their rate limit will be deprioritized
    /// and rate-limited providers will be skipped until their limit resets.
    /// </summary>
    public bool EnableRateLimitRotation { get; init; } = true;

    /// <summary>
    /// Threshold (0.0 to 1.0) at which a provider is considered "approaching" its rate limit.
    /// Providers exceeding this threshold will be deprioritized in favor of providers with more capacity.
    /// Default: 0.8 (80% of rate limit used).
    /// </summary>
    public double RateLimitRotationThreshold { get; init; } = 0.8;
}
