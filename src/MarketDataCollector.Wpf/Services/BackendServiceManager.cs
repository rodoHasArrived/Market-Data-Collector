using System;
using System.Diagnostics;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using MarketDataCollector.Ui.Services.Services;

namespace MarketDataCollector.Wpf.Services;

/// <summary>
/// WPF platform-specific backend service manager.
/// Extends <see cref="BackendServiceManagerBase"/> with process management and HTTP health checks.
/// Part of Phase 2 service extraction.
/// </summary>
public sealed class BackendServiceManager : BackendServiceManagerBase
{
    private static readonly Lazy<BackendServiceManager> _instance = new(() => new BackendServiceManager());
    private readonly HttpClient _httpClient;

    public static BackendServiceManager Instance => _instance.Value;

    private BackendServiceManager()
    {
        _httpClient = new HttpClient
        {
            Timeout = TimeSpan.FromSeconds(5)
        };
    }

    protected override string? ResolveExecutablePath(string? preferredPath)
    {
        if (!string.IsNullOrWhiteSpace(preferredPath) && File.Exists(preferredPath))
        {
            return preferredPath;
        }

        var configuredPath = Environment.GetEnvironmentVariable("MDC_BACKEND_PATH", EnvironmentVariableTarget.User);
        if (!string.IsNullOrWhiteSpace(configuredPath) && File.Exists(configuredPath))
        {
            return configuredPath;
        }

        var baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
        var candidates = new[]
        {
            Path.Combine(baseDirectory, "MarketDataCollector.exe"),
            Path.Combine(baseDirectory, "MarketDataCollector", "MarketDataCollector.exe"),
            Path.GetFullPath(Path.Combine(baseDirectory, "..", "MarketDataCollector", "MarketDataCollector.exe")),
            Path.GetFullPath(Path.Combine(baseDirectory, "..", "..", "..", "..", "MarketDataCollector", "bin", "Release", "net9.0", "MarketDataCollector.exe")),
            Path.GetFullPath(Path.Combine(baseDirectory, "..", "..", "..", "..", "MarketDataCollector", "bin", "Debug", "net9.0", "MarketDataCollector.exe"))
        };

        foreach (var candidate in candidates)
        {
            if (File.Exists(candidate)) return candidate;
        }

        return null;
    }

    protected override int? StartProcess(string executablePath, string workingDirectory)
    {
        var processStartInfo = new ProcessStartInfo
        {
            FileName = executablePath,
            WorkingDirectory = workingDirectory,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        var process = Process.Start(processStartInfo);
        return process?.Id;
    }

    protected override async Task<bool> KillProcessAsync(int processId, CancellationToken ct)
    {
        try
        {
            var process = Process.GetProcessById(processId);
            if (process.HasExited) return true;

            process.Kill(entireProcessTree: true);
            await process.WaitForExitAsync(ct);
            process.Dispose();
            return true;
        }
        catch
        {
            return false;
        }
    }

    protected override bool IsProcessRunning(int processId)
    {
        try
        {
            var process = Process.GetProcessById(processId);
            return !process.HasExited;
        }
        catch
        {
            return false;
        }
    }

    protected override async Task<bool> IsHealthyAsync(CancellationToken ct)
    {
        try
        {
            var response = await _httpClient.GetAsync($"{ConnectionService.Instance.ServiceUrl}/healthz", ct);
            return response.IsSuccessStatusCode;
        }
        catch
        {
            return false;
        }
    }

    protected override void LogInfo(string message, params (string key, string value)[] properties)
        => LoggingService.Instance.LogInfo(message, properties);

    protected override void LogError(string message, Exception? exception)
        => LoggingService.Instance.LogError(message, exception);
}
