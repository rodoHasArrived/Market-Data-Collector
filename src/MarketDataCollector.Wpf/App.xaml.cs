using System;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using MarketDataCollector.Wpf.Contracts;
using WpfServices = MarketDataCollector.Wpf.Services;
using MarketDataCollector.Wpf.Views;
using MarketDataCollector.Ui.Services;

namespace MarketDataCollector.Wpf;

/// <summary>
/// Market Data Collector WPF Application
/// Provides maximum stability through WPF (.NET 9) for Windows-only deployment.
/// </summary>
public partial class App : Application
{
    private static bool _isFirstRun;
    private static bool _isFixtureMode;
    private IHost? _host;

    /// <summary>
    /// Gets the service provider for dependency injection.
    /// </summary>
    public static IServiceProvider Services { get; private set; } = null!;

    /// <summary>
    /// Gets whether the application is running in fixture mode (offline mock data).
    /// Activated via --fixture command-line argument or MDC_FIXTURE_MODE=1 environment variable.
    /// </summary>
    public static bool IsFixtureMode => _isFixtureMode;

    /// <summary>
    /// Gets the main application window.
    /// </summary>
    public static new MainWindow? MainWindow => Current.MainWindow as MainWindow;

    /// <summary>
    /// Gets whether this is the first run of the application.
    /// </summary>
    public static bool IsFirstRun => _isFirstRun;

    /// <summary>
    /// Gets the notification service instance.
    /// </summary>
    public static WpfServices.NotificationService Notifications => WpfServices.NotificationService.Instance;

    /// <summary>
    /// Gets the connection service instance.
    /// </summary>
    public static WpfServices.ConnectionService Connection => WpfServices.ConnectionService.Instance;

    /// <summary>
    /// Gets the theme service instance.
    /// </summary>
    public static WpfServices.ThemeService Theme => WpfServices.ThemeService.Instance;

    /// <summary>
    /// Gets the offline tracking persistence service instance.
    /// </summary>
    public static WpfServices.OfflineTrackingPersistenceService OfflineTracking => WpfServices.OfflineTrackingPersistenceService.Instance;

    /// <summary>
    /// Gets the background task scheduler service instance.
    /// </summary>
    public static WpfServices.BackgroundTaskSchedulerService Scheduler => WpfServices.BackgroundTaskSchedulerService.Instance;

    /// <summary>
    /// Gets the pending operations queue service instance.
    /// </summary>
    public static WpfServices.PendingOperationsQueueService OperationsQueue => WpfServices.PendingOperationsQueueService.Instance;

    private async void OnStartup(object sender, StartupEventArgs e)
    {
        // Detect fixture mode from --fixture arg or MDC_FIXTURE_MODE env var
        _isFixtureMode = DetectFixtureMode(e.Args);

        // Configure the host with dependency injection
        _host = Host.CreateDefaultBuilder()
            .ConfigureServices((context, services) =>
            {
                ConfigureServices(services);
            })
            .Build();

        Services = _host.Services;

        // Provide the DI container to NavigationService so it can resolve pages
        WpfServices.NavigationService.Instance.SetServiceProvider(Services);

        // Handle unhandled exceptions gracefully
        DispatcherUnhandledException += OnDispatcherUnhandledException;
        AppDomain.CurrentDomain.UnhandledException += OnDomainUnhandledException;
        TaskScheduler.UnobservedTaskException += OnUnobservedTaskException;

        // Create and show MainWindow from DI (replaces StartupUri)
        var mainWindow = Services.GetRequiredService<MainWindow>();
        Current.MainWindow = mainWindow;
        mainWindow.Show();

        // Fire-and-forget async initialization with proper exception handling
        await SafeOnStartupAsync();
    }

    /// <summary>
    /// Detects whether fixture mode should be activated.
    /// Checks for --fixture command-line argument or MDC_FIXTURE_MODE=1 environment variable.
    /// </summary>
    private static bool DetectFixtureMode(string[] args)
    {
        // Check command-line argument
        if (Array.Exists(args, arg => string.Equals(arg, "--fixture", StringComparison.OrdinalIgnoreCase)))
            return true;

        // Check environment variable
        var envValue = Environment.GetEnvironmentVariable("MDC_FIXTURE_MODE");
        return string.Equals(envValue, "1", StringComparison.Ordinal)
            || string.Equals(envValue, "true", StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Configures services for dependency injection.
    /// C1: DI-first registration — services registered by interface where possible.
    /// Pages registered as transient for constructor injection via NavigationService.
    /// </summary>
    private static void ConfigureServices(IServiceCollection services)
    {
        // Register HttpClient factory
        services.AddHttpClient();

        // ── Fixture mode service (offline mock data) ────────────────────────
        services.AddSingleton(_ => MarketDataCollector.Ui.Services.Services.FixtureDataService.Instance);

        // ── Core services (by interface + concrete type) ────────────────────
        services.AddSingleton<IConnectionService>(_ => WpfServices.ConnectionService.Instance);
        services.AddSingleton(_ => WpfServices.ConnectionService.Instance);

        services.AddSingleton<INavigationService>(_ => WpfServices.NavigationService.Instance);
        services.AddSingleton(_ => WpfServices.NavigationService.Instance);

        services.AddSingleton<MarketDataCollector.Ui.Services.Contracts.ILoggingService>(_ => WpfServices.LoggingService.Instance);
        services.AddSingleton(_ => WpfServices.LoggingService.Instance);

        services.AddSingleton(_ => WpfServices.ConfigService.Instance);
        services.AddSingleton(_ => WpfServices.ThemeService.Instance);
        services.AddSingleton(_ => WpfServices.NotificationService.Instance);
        services.AddSingleton(_ => WpfServices.KeyboardShortcutService.Instance);
        services.AddSingleton(_ => WpfServices.MessagingService.Instance);
        services.AddSingleton(_ => WpfServices.StatusService.Instance);
        services.AddSingleton(_ => WpfServices.FirstRunService.Instance);

        // ── Domain / feature services ───────────────────────────────────────
        services.AddSingleton(_ => WpfServices.BackendServiceManager.Instance);
        services.AddSingleton(_ => WpfServices.WatchlistService.Instance);
        services.AddSingleton(_ => WpfServices.ArchiveHealthService.Instance);
        services.AddSingleton(_ => WpfServices.SchemaService.Instance);
        services.AddSingleton(_ => WpfServices.AdminMaintenanceService.Instance);
        services.AddSingleton<AdvancedAnalyticsServiceBase>(_ => new AdvancedAnalyticsServiceBase());
        services.AddSingleton(_ => SearchService.Instance);

        // ── Background / infrastructure services ────────────────────────────
        services.AddSingleton(_ => WpfServices.BackgroundTaskSchedulerService.Instance);
        services.AddSingleton(_ => WpfServices.OfflineTrackingPersistenceService.Instance);
        services.AddSingleton(_ => WpfServices.PendingOperationsQueueService.Instance);

        // ── MainWindow ──────────────────────────────────────────────────────
        services.AddSingleton<MainWindow>();

        // ── Pages (transient — created per navigation) ──────────────────────
        services.AddTransient<MainPage>();
        services.AddTransient<DashboardPage>();
        services.AddTransient<WatchlistPage>();
        services.AddTransient<ProviderPage>();
        services.AddTransient<ProviderHealthPage>();
        services.AddTransient<DataSourcesPage>();
        services.AddTransient<LiveDataViewerPage>();
        services.AddTransient<SymbolsPage>();
        services.AddTransient<SymbolMappingPage>();
        services.AddTransient<SymbolStoragePage>();
        services.AddTransient<StoragePage>();
        services.AddTransient<BackfillPage>();
        services.AddTransient<PortfolioImportPage>();
        services.AddTransient<IndexSubscriptionPage>();
        services.AddTransient<ScheduleManagerPage>();
        services.AddTransient<DataQualityPage>();
        services.AddTransient<CollectionSessionPage>();
        services.AddTransient<ArchiveHealthPage>();
        services.AddTransient<ServiceManagerPage>();
        services.AddTransient<SystemHealthPage>();
        services.AddTransient<DiagnosticsPage>();
        services.AddTransient<DataExportPage>();
        services.AddTransient<DataSamplingPage>();
        services.AddTransient<TimeSeriesAlignmentPage>();
        services.AddTransient<ExportPresetsPage>();
        services.AddTransient<AnalysisExportPage>();
        services.AddTransient<AnalysisExportWizardPage>();
        services.AddTransient<EventReplayPage>();
        services.AddTransient<PackageManagerPage>();
        services.AddTransient<TradingHoursPage>();
        services.AddTransient<AdvancedAnalyticsPage>();
        services.AddTransient<ChartingPage>();
        services.AddTransient<OrderBookPage>();
        services.AddTransient<DataCalendarPage>();
        services.AddTransient<StorageOptimizationPage>();
        services.AddTransient<RetentionAssurancePage>();
        services.AddTransient<AdminMaintenancePage>();
        services.AddTransient<LeanIntegrationPage>();
        services.AddTransient<MessagingHubPage>();
        services.AddTransient<MarketDataCollector.Wpf.Views.WorkspacePage>();
        services.AddTransient<NotificationCenterPage>();
        services.AddTransient<HelpPage>();
        services.AddTransient<WelcomePage>();
        services.AddTransient<SettingsPage>();
        services.AddTransient<KeyboardShortcutsPage>();
        services.AddTransient<SetupWizardPage>();
        services.AddTransient<ActivityLogPage>();
        services.AddTransient<DataBrowserPage>();
    }

    /// <summary>
    /// Performs async initialization with proper exception handling.
    /// </summary>
    private async Task SafeOnStartupAsync()
    {
        try
        {
            // Run first-time setup before showing window
            await InitializeFirstRunAsync();

            // Initialize and validate configuration
            await InitializeConfigurationAsync();

            // Initialize theme service
            if (Current.MainWindow is MainWindow mainWindow)
            {
                WpfServices.ThemeService.Instance.Initialize(mainWindow);
            }

            // Start connection monitoring
            WpfServices.ConnectionService.Instance.StartMonitoring();

            // Initialize offline tracking persistence (handles recovery from crashes/restarts)
            await InitializeOfflineTrackingAsync();

            // Start background task scheduler
            await InitializeBackgroundServicesAsync();

            // Notify if running in fixture mode
            if (_isFixtureMode)
            {
                WpfServices.LoggingService.Instance.LogWarning("Running in FIXTURE MODE — using offline mock data");
                await WpfServices.NotificationService.Instance.NotifyWarningAsync(
                    "Fixture Mode Active",
                    "Application is using mock data for offline development");
            }

            // Log successful startup
            WpfServices.LoggingService.Instance.LogInfo("Application started successfully");
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[App] Error during application startup: {ex.Message}");
        }
    }

    /// <summary>
    /// Initializes offline tracking persistence and performs recovery if needed.
    /// </summary>
    private static async Task InitializeOfflineTrackingAsync()
    {
        try
        {
            await WpfServices.OfflineTrackingPersistenceService.Instance.InitializeAsync();
            System.Diagnostics.Debug.WriteLine("Offline tracking persistence initialized");
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to initialize offline tracking: {ex.Message}");
            // Continue - app should still work without persistence
        }
    }

    /// <summary>
    /// Initializes background services for scheduled tasks and offline queue processing.
    /// </summary>
    private static async Task InitializeBackgroundServicesAsync()
    {
        try
        {
            // Initialize pending operations queue
            await WpfServices.PendingOperationsQueueService.Instance.InitializeAsync();
            System.Diagnostics.Debug.WriteLine("Pending operations queue initialized");

            // Start background task scheduler
            await WpfServices.BackgroundTaskSchedulerService.Instance.StartAsync();
            System.Diagnostics.Debug.WriteLine("Background task scheduler started");
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Failed to initialize background services: {ex.Message}");
            // Continue - app should still work without background services
        }
    }

    /// <summary>
    /// Handles app exit for clean shutdown of background services with timeout.
    /// </summary>
    private async void OnExit(object sender, ExitEventArgs e)
    {
        await SafeOnExitAsync();
        _host?.Dispose();
    }

    /// <summary>
    /// Performs async shutdown with proper exception handling.
    /// </summary>
    private static async Task SafeOnExitAsync()
    {
        const int ShutdownTimeoutMs = 5000; // 5 second timeout for graceful shutdown

        try
        {
            System.Diagnostics.Debug.WriteLine("App exiting, shutting down services...");

            using var cts = new CancellationTokenSource(ShutdownTimeoutMs);

            // Shutdown services in parallel with timeout for better performance
            var shutdownTasks = new[]
            {
                ShutdownServiceAsync(() => WpfServices.BackgroundTaskSchedulerService.Instance.StopAsync(), "BackgroundTaskScheduler", cts.Token),
                ShutdownServiceAsync(() => WpfServices.PendingOperationsQueueService.Instance.ShutdownAsync(), "PendingOperationsQueue", cts.Token),
                ShutdownServiceAsync(() => WpfServices.OfflineTrackingPersistenceService.Instance.ShutdownAsync(), "OfflineTrackingPersistence", cts.Token),
                ShutdownServiceAsync(() => WpfServices.ConnectionService.Instance.StopMonitoring(), "ConnectionService", cts.Token)
            };

            await Task.WhenAll(shutdownTasks);

            System.Diagnostics.Debug.WriteLine("Services shut down cleanly");
        }
        catch (OperationCanceledException)
        {
            System.Diagnostics.Debug.WriteLine("App shutdown timed out - forcing exit");
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"[App] Error during app exit: {ex.Message}");
        }
    }

    /// <summary>
    /// Helper method to shutdown a service with proper error handling.
    /// </summary>
    private static async Task ShutdownServiceAsync(Func<Task> shutdownAction, string serviceName, CancellationToken ct)
    {
        try
        {
            await shutdownAction().WaitAsync(ct);
            System.Diagnostics.Debug.WriteLine($"{serviceName} shut down successfully");
        }
        catch (OperationCanceledException)
        {
            System.Diagnostics.Debug.WriteLine($"{serviceName} shutdown timed out");
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"{serviceName} shutdown failed: {ex.Message}");
        }
    }

    /// <summary>
    /// Helper method to shutdown a synchronous service.
    /// </summary>
    private static async Task ShutdownServiceAsync(Action shutdownAction, string serviceName, CancellationToken ct)
    {
        await Task.Run(() =>
        {
            try
            {
                ct.ThrowIfCancellationRequested();
                shutdownAction();
                System.Diagnostics.Debug.WriteLine($"{serviceName} shut down successfully");
            }
            catch (OperationCanceledException)
            {
                System.Diagnostics.Debug.WriteLine($"{serviceName} shutdown timed out");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"{serviceName} shutdown failed: {ex.Message}");
            }
        }, ct);
    }

    /// <summary>
    /// Performs first-run initialization including config setup.
    /// </summary>
    private static async Task InitializeFirstRunAsync()
    {
        try
        {
            var firstRunService = WpfServices.FirstRunService.Instance;
            _isFirstRun = await firstRunService.IsFirstRunAsync();

            if (_isFirstRun)
            {
                await firstRunService.InitializeAsync();
            }
        }
        catch (Exception ex)
        {
            // Q2: Log first-run setup failures instead of silently swallowing
            System.Diagnostics.Debug.WriteLine($"[App] First-run setup failed: {ex.Message}");
        }
    }

    /// <summary>
    /// Initializes and validates the application configuration.
    /// </summary>
    private static async Task InitializeConfigurationAsync()
    {
        try
        {
            // Initialize the config service
            await WpfServices.ConfigService.Instance.InitializeAsync();

            // Validate configuration
            var validationResult = await WpfServices.ConfigService.Instance.ValidateConfigAsync();

            if (!validationResult.IsValid)
            {
                foreach (var error in validationResult.Errors)
                {
                    WpfServices.LoggingService.Instance.LogError("Configuration error: " + error);
                }
            }

            foreach (var warning in validationResult.Warnings)
            {
                WpfServices.LoggingService.Instance.LogWarning("Configuration warning: " + warning);
            }

            WpfServices.LoggingService.Instance.LogInfo("Configuration initialized",
                ("isValid", validationResult.IsValid.ToString()),
                ("errors", validationResult.Errors.Length.ToString()),
                ("warnings", validationResult.Warnings.Length.ToString()));
        }
        catch (Exception ex)
        {
            WpfServices.LoggingService.Instance.LogError("Failed to initialize configuration", ex);
            // Continue - app should still work with defaults
        }
    }

    /// <summary>
    /// Handles unhandled exceptions on the UI thread.
    /// </summary>
    private void OnDispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
    {
        // Log the exception but don't crash
        System.Diagnostics.Debug.WriteLine($"Dispatcher unhandled exception: {e.Exception}");
        e.Handled = true;

        // Notify user of the error
        try
        {
            _ = WpfServices.NotificationService.Instance.NotifyErrorAsync(
                "Application Error",
                e.Exception.Message);
        }
        catch (Exception ex)
        {
            // Q2: Log notification failures instead of silently swallowing
            System.Diagnostics.Debug.WriteLine($"[App] Notification failure during error handling: {ex.Message}");
        }
    }

    /// <summary>
    /// Handles unhandled exceptions from non-UI threads.
    /// </summary>
    private void OnDomainUnhandledException(object sender, UnhandledExceptionEventArgs e)
    {
        if (e.ExceptionObject is Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Domain unhandled exception: {ex}");
        }
    }

    /// <summary>
    /// Handles unobserved task exceptions.
    /// </summary>
    private void OnUnobservedTaskException(object? sender, UnobservedTaskExceptionEventArgs e)
    {
        System.Diagnostics.Debug.WriteLine($"Unobserved task exception: {e.Exception}");
        e.SetObserved(); // Prevent the process from terminating
    }
}
