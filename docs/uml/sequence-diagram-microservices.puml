@startuml Sequence Diagram - Microservices Data Ingestion
!theme plain
skinparam sequenceMessageAlign center

title Market Data Collector - Microservices Data Ingestion

' ==================== PARTICIPANTS ====================
participant "External Client" as Client
participant "Gateway\n(Port 5000)" as Gateway
participant "DataRouter" as Router
participant "MassTransit\nBus" as Bus
box "Microservices" #LightYellow
    participant "TradeIngestion\n(Port 5001)" as TradeSvc
    participant "QuoteIngestion\n(Port 5002)" as QuoteSvc
    participant "DataValidation\n(Port 5005)" as ValidationSvc
end box
participant "DeadLetterQueue" as DLQ
participant "Storage" as Storage

' ==================== TRADE INGESTION ====================
== Trade Ingestion Flow ==

Client -> Gateway: POST /api/v1/ingest/trades\n{symbol:"SPY", price:450.25, size:100}
activate Gateway

Gateway -> Gateway: RateLimitMiddleware.Check()
alt Rate Limit Exceeded
    Gateway --> Client: 429 Too Many Requests
else
    Gateway -> Gateway: ValidateInput()

    Gateway -> Router: RouteAsync(Trade, "SPY", payload)
    activate Router

    Router -> Router: ResolveTargetService(Trade)\nâ†’ "TradeIngestion"
    Router -> Router: CreateRoutedMessage()
    note right
      IRouteIngestionData {
        MessageId: guid,
        Symbol: "SPY",
        DataType: Trade,
        Source: "external",
        RawPayload: json
      }
    end note

    Router -> Bus: Publish(IRawTradeIngested)
    Bus --> Router: OK

    Router -> Router: RecordSuccess()
    Router --> Gateway: MessageId
    deactivate Router

    Gateway --> Client: 202 Accepted\n{messageId: "abc-123"}
end
deactivate Gateway

' --- Async Processing ---
Bus -> TradeSvc: Consume(IRawTradeIngested)
activate TradeSvc

TradeSvc -> TradeSvc: RawTradeConsumer.Consume()
TradeSvc -> TradeSvc: Deserialize(payload)
TradeSvc -> TradeSvc: CreateProcessedTrade()

TradeSvc -> TradeSvc: _processor.TrySubmit(trade)
note right: Bounded channel\nwith backpressure

alt Channel Full
    TradeSvc -> TradeSvc: Log.Warning("Queue full, dropping")
else
    TradeSvc -> TradeSvc: TradeProcessor reads from channel

    TradeSvc -> TradeSvc: TradeValidator.Validate()
    note right
      - Check duplicates
      - Verify price bounds
      - Validate size > 0
    end note

    alt Validation Failed
        TradeSvc -> DLQ: SendAsync(trade, error)
        DLQ --> TradeSvc: OK
    else
        TradeSvc -> Storage: TradeStorage.WriteAsync(trade)
        Storage --> TradeSvc: OK
        TradeSvc -> TradeSvc: TradeMetrics.IncSuccess()
    end
end

deactivate TradeSvc

' ==================== BATCH INGESTION ====================
== Batch Trade Ingestion ==

Client -> Gateway: POST /api/v1/ingest/trades/batch\n[{trade1}, {trade2}, ..., {trade100}]
activate Gateway

Gateway -> Gateway: ValidateBatch()
Gateway -> Router: RouteBatchAsync(trades[])
activate Router

Router -> Router: GroupBySymbol(trades)
loop For Each Symbol Group
    Router -> Bus: Publish(IIngestTradesBatch)
end
Router --> Gateway: batchId
deactivate Router

Gateway --> Client: 202 Accepted\n{batchId: "xyz-789", count: 100}
deactivate Gateway

' --- Batch Processing ---
Bus -> TradeSvc: Consume(IIngestTradesBatch)
activate TradeSvc

loop For Each Trade in Batch
    TradeSvc -> TradeSvc: Process(trade)
end

TradeSvc -> Bus: Publish(ITradesBatchIngested)
note right: Completion event\nfor tracking
deactivate TradeSvc

' ==================== VALIDATION REQUEST ====================
== Data Validation Flow ==

Client -> Gateway: POST /api/v1/validate\n{symbol:"SPY", from:"2024-01-01", to:"2024-01-31"}
activate Gateway

Gateway -> Router: RouteAsync(Validation, request)
Router -> Bus: Publish(IValidationRequest)
Bus --> Router: OK
Router --> Gateway: requestId
Gateway --> Client: 202 Accepted
deactivate Gateway

Bus -> ValidationSvc: Consume(IValidationRequest)
activate ValidationSvc

ValidationSvc -> ValidationSvc: ValidationRequestConsumer.Consume()
ValidationSvc -> ValidationSvc: DataValidator.ValidateRange()
note right
  Checks:
  - Sequence gaps
  - Outlier prices
  - Crossed markets
  - Stale data periods
end note

ValidationSvc -> ValidationSvc: QualityMetricsAggregator.Compute()
note right
  Metrics:
  - Completeness %
  - Gap count
  - Anomaly count
end note

ValidationSvc -> Bus: Publish(IValidationCompleted)
note right
  ValidationResult {
    Symbol: "SPY",
    IsValid: true,
    GapsFound: 2,
    AnomaliesFound: 0,
    Completeness: 99.2%
  }
end note

deactivate ValidationSvc

@enduml
