name: Release Management

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.0)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Validate version format
      run: |
        if [[ ! "${{ github.event.inputs.version }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
          echo "Error: Version must follow semantic versioning (e.g., v1.2.0 or v1.2.0-beta.1)"
          exit 1
        fi

    - name: Check if tag exists
      run: |
        if git rev-parse "${{ github.event.inputs.version }}" >/dev/null 2>&1; then
          echo "Error: Tag ${{ github.event.inputs.version }} already exists"
          exit 1
        fi

    - name: Setup .NET
      uses: actions/setup-dotnet@v5.1.0
      with:
        dotnet-version: '9.0.x'

    - name: Pre-flight build check
      run: |
        echo "Running pre-flight build validation..."
        dotnet restore MarketDataCollector.sln /p:EnableWindowsTargeting=true
        dotnet build MarketDataCollector.sln -c Release --no-restore /p:EnableWindowsTargeting=true
        dotnet test MarketDataCollector.sln -c Release --no-build /p:EnableWindowsTargeting=true --logger "console;verbosity=normal"
        echo "Pre-flight checks passed."

    - name: Generate changelog
      id: changelog
      uses: actions/github-script@v8
      with:
        result-encoding: string
        script: |
          // Get the latest tag to scope the changelog
          let sinceDate;
          try {
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 1,
            });
            if (tags.length > 0) {
              const { data: tagCommit } = await github.rest.git.getCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: tags[0].commit.sha,
              });
              sinceDate = tagCommit.committer.date;
            }
          } catch (e) {
            // No previous tags, use last 100 commits
          }

          const params = {
            owner: context.repo.owner,
            repo: context.repo.repo,
            per_page: 100,
          };
          if (sinceDate) params.since = sinceDate;

          const { data: commits } = await github.rest.repos.listCommits(params);

          // Categorize by conventional commit prefix
          const categories = {
            'Features': [],
            'Bug Fixes': [],
            'Performance': [],
            'Documentation': [],
            'CI/CD': [],
            'Other': [],
          };

          for (const commit of commits) {
            const msg = commit.commit.message.split('\n')[0];
            if (!msg) continue;
            const sha = commit.sha.substring(0, 7);
            const entry = `- ${msg} (${sha})`;

            if (/^feat(\(|:|\!)/.test(msg)) categories['Features'].push(entry);
            else if (/^fix(\(|:|\!)/.test(msg)) categories['Bug Fixes'].push(entry);
            else if (/^perf(\(|:|\!)/.test(msg)) categories['Performance'].push(entry);
            else if (/^docs?(\(|:|\!)/.test(msg)) categories['Documentation'].push(entry);
            else if (/^(ci|build|chore)(\(|:|\!)/.test(msg)) categories['CI/CD'].push(entry);
            else categories['Other'].push(entry);
          }

          let changelog = '## What\'s Changed\n\n';
          for (const [category, entries] of Object.entries(categories)) {
            if (entries.length > 0) {
              changelog += `### ${category}\n${entries.join('\n')}\n\n`;
            }
          }

          return changelog.trim();

    - name: Create and push tag
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "${{ github.event.inputs.version }}" -m "Release ${{ github.event.inputs.version }}"
        git push origin "${{ github.event.inputs.version }}"

    - name: Create GitHub Release
      uses: actions/github-script@v8
      env:
        RELEASE_VERSION: ${{ github.event.inputs.version }}
        RELEASE_BODY: ${{ steps.changelog.outputs.result }}
        IS_PRERELEASE: ${{ github.event.inputs.prerelease }}
      with:
        script: |
          await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: process.env.RELEASE_VERSION,
            name: process.env.RELEASE_VERSION,
            body: process.env.RELEASE_BODY,
            draft: false,
            prerelease: process.env.IS_PRERELEASE === 'true',
          });

    - name: Trigger build workflow
      uses: actions/github-script@v8
      with:
        script: |
          await github.rest.actions.createWorkflowDispatch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'dotnet-desktop.yml',
            ref: '${{ github.event.inputs.version }}',
          });
