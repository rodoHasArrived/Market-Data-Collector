#!/usr/bin/env python3
"""Create GitHub issues for untracked TODO items.

Consumes JSON generated by `scan-todos.py` and creates issues for TODO entries
that do not already reference an issue number.
"""

from __future__ import annotations

import argparse
import json
import os
import re
import sys
import urllib.error
import urllib.parse
import urllib.request
from dataclasses import dataclass
from pathlib import Path
from typing import Any


DEFAULT_LABEL = "auto-todo"
MAX_TITLE_LENGTH = 120


@dataclass
class TodoItem:
    type: str
    text: str
    file: str
    line: int
    has_issue: bool
    issue_refs: list[str]
    priority: str
    context: str = ""


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Create GitHub issues for untracked TODO items")
    parser.add_argument("--scan-json", type=Path, required=True, help="Path to scan-todos JSON output")
    parser.add_argument("--repo", default=os.getenv("GITHUB_REPOSITORY", ""), help="owner/repo")
    parser.add_argument("--token", default=os.getenv("GITHUB_TOKEN") or os.getenv("GH_TOKEN", ""), help="GitHub token")
    parser.add_argument("--label", default=DEFAULT_LABEL, help="Label to add to created issues")
    parser.add_argument("--max-issues", type=int, default=20, help="Maximum issues to create per run")
    parser.add_argument("--dry-run", action="store_true", help="Report what would be created")
    parser.add_argument("--output-json", type=Path, help="Write machine-readable summary JSON")
    return parser.parse_args()


def gh_request(method: str, url: str, token: str, payload: dict[str, Any] | None = None) -> Any:
    data = None
    if payload is not None:
        data = json.dumps(payload).encode("utf-8")

    req = urllib.request.Request(url=url, method=method, data=data)
    req.add_header("Accept", "application/vnd.github+json")
    req.add_header("X-GitHub-Api-Version", "2022-11-28")
    req.add_header("User-Agent", "market-data-collector-docs-bot")
    req.add_header("Authorization", f"Bearer {token}")
    if data is not None:
        req.add_header("Content-Type", "application/json")

    try:
        with urllib.request.urlopen(req, timeout=30) as response:
            body = response.read().decode("utf-8")
            if not body:
                return {}
            return json.loads(body)
    except json.JSONDecodeError as exc:
        print(f"Warning: JSON decode error for {url}: {exc}", file=sys.stderr)
        raise
    except urllib.error.HTTPError as exc:
        print(f"Warning: HTTP {exc.code} for {url}: {exc.reason}", file=sys.stderr)
        raise


def load_todos(path: Path) -> list[TodoItem]:
    try:
        content = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        print(f"Error: scan JSON file not found: {path}", file=sys.stderr)
        raise
    except Exception as exc:
        print(f"Error: failed to read scan JSON: {exc}", file=sys.stderr)
        raise
    
    try:
        payload = json.loads(content)
    except json.JSONDecodeError as exc:
        print(f"Error: invalid JSON in scan file: {exc}", file=sys.stderr)
        raise
    
    if not isinstance(payload, dict):
        raise ValueError(f"Expected JSON object at root, got {type(payload).__name__}")
    
    todos_list = payload.get("todos", [])
    if not isinstance(todos_list, list):
        raise ValueError(f"Expected 'todos' to be a list, got {type(todos_list).__name__}")
    
    items = []
    for raw in todos_list:
        if not isinstance(raw, dict):
            print(f"Warning: skipping non-dict TODO entry: {raw}", file=sys.stderr)
            continue
        items.append(
            TodoItem(
                type=str(raw.get("type", "TODO")),
                text=str(raw.get("text", "")).strip(),
                file=str(raw.get("file", "")),
                line=int(raw.get("line", 0)),
                has_issue=bool(raw.get("has_issue", False)),
                issue_refs=[str(v) for v in raw.get("issue_refs", [])],
                priority=str(raw.get("priority", "normal")),
                context=str(raw.get("context", "")),
            )
        )
    return items


def fingerprint(todo: TodoItem) -> str:
    return f"TODO-SOURCE: {todo.file}:{todo.line}"


def compact_title(todo: TodoItem) -> str:
    summary = re.sub(r"\s+", " ", todo.text).strip()
    prefix = f"[{todo.type}] "
    max_summary_len = MAX_TITLE_LENGTH - len(prefix) - 3  # reserve space for "..."
    if len(summary) > max_summary_len:
        summary = summary[:max_summary_len].rstrip() + "..."
    title = prefix + summary
    # Final safety check
    if len(title) > MAX_TITLE_LENGTH:
        title = title[:MAX_TITLE_LENGTH - 3] + "..."
    return title


def ensure_label(repo: str, token: str, label: str, dry_run: bool) -> None:
    if dry_run:
        return
    url = f"https://api.github.com/repos/{repo}/labels/{urllib.parse.quote(label)}"
    try:
        gh_request("GET", url, token)
        return
    except urllib.error.HTTPError as exc:
        if exc.code != 404:
            raise

    create_url = f"https://api.github.com/repos/{repo}/labels"
    gh_request("POST", create_url, token, {"name": label, "color": "0e8a16", "description": "Auto-created from TODO scanner"})


def find_existing_issue(repo: str, token: str, marker: str) -> int | None:
    query = urllib.parse.quote(f'repo:{repo} "{marker}" in:body')
    url = f"https://api.github.com/search/issues?q={query}&per_page=1"
    try:
        result = gh_request("GET", url, token)
    except (urllib.error.HTTPError, json.JSONDecodeError):
        return None

    if not isinstance(result, dict):
        return None
    items = result.get("items", [])
    if not items:
        return None
    return int(items[0].get("number", 0))


def create_issue(repo: str, token: str, todo: TodoItem, label: str, dry_run: bool) -> tuple[str, int | None]:
    """Create or find issue for a TODO item.
    
    Returns:
        Tuple of (status, issue_number) where status is one of:
        - "existing": Issue already exists
        - "created": New issue created
        - "dry-run": Dry run mode (no issue created)
    """
    marker = fingerprint(todo)
    existing = find_existing_issue(repo, token, marker) if token and repo else None
    if existing is not None:
        return ("existing", existing)

    if dry_run:
        return ("dry-run", None)

    url = f"https://api.github.com/repos/{repo}/issues"
    body = "\n".join(
        [
            "## Auto-created TODO",
            "",
            f"- Type: `{todo.type}`",
            f"- Source: `{todo.file}:{todo.line}`",
            f"- Priority: `{todo.priority}`",
            "",
            "### TODO text",
            todo.text or "(No text provided)",
            "",
            "### Context",
            "```text",
            todo.context or "(No context captured)",
            "```",
            "",
            marker,
            "",
            "_This issue was generated automatically from `build/scripts/docs/scan-todos.py`._",
        ]
    )
    try:
        created = gh_request(
            "POST",
            url,
            token,
            {"title": compact_title(todo), "body": body, "labels": [label]},
        )
        return ("created", int(created.get("number", 0)))
    except (urllib.error.HTTPError, json.JSONDecodeError, KeyError) as exc:
        print(f"Failed to create issue: {exc}", file=sys.stderr)
        raise


def main() -> int:
    args = parse_args()

    if not args.scan_json.exists():
        print(f"Error: scan json not found: {args.scan_json}", file=sys.stderr)
        return 2

    if not args.dry_run and (not args.repo or not args.token):
        print("Error: --repo and --token (or env vars) are required unless --dry-run is used", file=sys.stderr)
        return 2

    try:
        todos = load_todos(args.scan_json)
    except (json.JSONDecodeError, ValueError, FileNotFoundError) as exc:
        print(f"Error: failed to load TODOs: {exc}", file=sys.stderr)
        return 2

    untracked = [todo for todo in todos if not todo.has_issue]

    if not untracked:
        print("No untracked TODO items found.")
        summary = {
            "created": 0,
            "existing": 0,
            "dry_run": 0,
            "skipped": 0,
            "total_untracked": 0,
            "issues": [],
        }
        if args.output_json:
            args.output_json.parent.mkdir(parents=True, exist_ok=True)
            args.output_json.write_text(json.dumps(summary, indent=2) + "\n", encoding="utf-8")
        return 0

    if not args.dry_run:
        try:
            ensure_label(args.repo, args.token, args.label, dry_run=False)
        except Exception as exc:
            print(f"Warning: failed to ensure label exists: {exc}", file=sys.stderr)

    created = 0
    existing_count = 0
    dry_run_count = 0
    skipped = 0
    issues_list = []
    
    for todo in untracked:
        if created + existing_count + dry_run_count >= args.max_issues:
            skipped += 1
            continue

        try:
            status, number = create_issue(args.repo, args.token, todo, args.label, args.dry_run)
        except Exception as exc:
            print(f"Failed to create issue for {todo.file}:{todo.line}: {exc}", file=sys.stderr)
            skipped += 1
            continue

        if status == "created":
            print(f"Issue #{number} created for {todo.file}:{todo.line}")
            created += 1
            issues_list.append({"status": "created", "number": number, "file": todo.file, "line": todo.line})
        elif status == "existing":
            print(f"Issue #{number} already exists for {todo.file}:{todo.line}")
            existing_count += 1
            issues_list.append({"status": "existing", "number": number, "file": todo.file, "line": todo.line})
        elif status == "dry-run":
            print(f"[dry-run] would create issue for {todo.file}:{todo.line} :: {todo.text}")
            dry_run_count += 1
            issues_list.append({"status": "dry-run", "number": None, "file": todo.file, "line": todo.line})

    total_processed = created + existing_count + dry_run_count
    print(
        f"TODO issue creation complete: "
        f"created={created}, existing={existing_count}, dry_run={dry_run_count}, "
        f"skipped={skipped}, total_untracked={len(untracked)}"
    )

    if args.output_json:
        summary = {
            "created": created,
            "existing": existing_count,
            "dry_run": dry_run_count,
            "skipped": skipped,
            "total_untracked": len(untracked),
            "issues": issues_list,
        }
        args.output_json.parent.mkdir(parents=True, exist_ok=True)
        args.output_json.write_text(json.dumps(summary, indent=2) + "\n", encoding="utf-8")
        print(f"Wrote summary JSON: {args.output_json}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
