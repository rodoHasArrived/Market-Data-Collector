#!/usr/bin/env python3
"""Create GitHub issues for untracked TODO items.

Consumes JSON generated by `scan-todos.py` and creates issues for TODO entries
that do not already reference an issue number.
"""

from __future__ import annotations

import argparse
import json
import os
import re
import sys
import urllib.error
import urllib.parse
import urllib.request
from dataclasses import dataclass
from pathlib import Path
from typing import Any


DEFAULT_LABEL = "auto-todo"


@dataclass
class TodoItem:
    type: str
    text: str
    file: str
    line: int
    has_issue: bool
    issue_refs: list[str]
    priority: str
    context: str = ""


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Create GitHub issues for untracked TODO items")
    parser.add_argument("--scan-json", type=Path, required=True, help="Path to scan-todos JSON output")
    parser.add_argument("--repo", default=os.getenv("GITHUB_REPOSITORY", ""), help="owner/repo")
    parser.add_argument("--token", default=os.getenv("GITHUB_TOKEN") or os.getenv("GH_TOKEN", ""), help="GitHub token")
    parser.add_argument("--label", default=DEFAULT_LABEL, help="Label to add to created issues")
    parser.add_argument("--max-issues", type=int, default=20, help="Maximum issues to create per run")
    parser.add_argument("--dry-run", action="store_true", help="Report what would be created")
    return parser.parse_args()


def gh_request(method: str, url: str, token: str, payload: dict[str, Any] | None = None) -> Any:
    data = None
    if payload is not None:
        data = json.dumps(payload).encode("utf-8")

    req = urllib.request.Request(url=url, method=method, data=data)
    req.add_header("Accept", "application/vnd.github+json")
    req.add_header("X-GitHub-Api-Version", "2022-11-28")
    req.add_header("User-Agent", "market-data-collector-docs-bot")
    req.add_header("Authorization", f"Bearer {token}")
    if data is not None:
        req.add_header("Content-Type", "application/json")

    with urllib.request.urlopen(req, timeout=30) as response:
        return json.loads(response.read().decode("utf-8"))


def load_todos(path: Path) -> list[TodoItem]:
    payload = json.loads(path.read_text(encoding="utf-8"))
    items = []
    for raw in payload.get("todos", []):
        items.append(
            TodoItem(
                type=str(raw.get("type", "TODO")),
                text=str(raw.get("text", "")).strip(),
                file=str(raw.get("file", "")),
                line=int(raw.get("line", 0)),
                has_issue=bool(raw.get("has_issue", False)),
                issue_refs=[str(v) for v in raw.get("issue_refs", [])],
                priority=str(raw.get("priority", "normal")),
                context=str(raw.get("context", "")),
            )
        )
    return items


def fingerprint(todo: TodoItem) -> str:
    return f"TODO-SOURCE: {todo.file}:{todo.line}"


def compact_title(todo: TodoItem) -> str:
    summary = re.sub(r"\s+", " ", todo.text).strip()
    if len(summary) > 72:
        summary = summary[:69].rstrip() + "..."
    return f"[{todo.type}] {summary}"


def ensure_label(repo: str, token: str, label: str, dry_run: bool) -> None:
    if dry_run:
        return
    url = f"https://api.github.com/repos/{repo}/labels/{urllib.parse.quote(label)}"
    try:
        gh_request("GET", url, token)
        return
    except urllib.error.HTTPError as exc:
        if exc.code != 404:
            raise

    create_url = f"https://api.github.com/repos/{repo}/labels"
    gh_request("POST", create_url, token, {"name": label, "color": "0e8a16", "description": "Auto-created from TODO scanner"})


def find_existing_issue(repo: str, token: str, marker: str) -> int | None:
    query = urllib.parse.quote(f'repo:{repo} "{marker}" in:body')
    url = f"https://api.github.com/search/issues?q={query}&per_page=1"
    try:
        result = gh_request("GET", url, token)
    except urllib.error.HTTPError:
        return None

    items = result.get("items", [])
    if not items:
        return None
    return int(items[0].get("number"))


def create_issue(repo: str, token: str, todo: TodoItem, label: str, dry_run: bool) -> int | None:
    marker = fingerprint(todo)
    existing = find_existing_issue(repo, token, marker) if token and repo else None
    if existing is not None:
        return existing

    if dry_run:
        return None

    url = f"https://api.github.com/repos/{repo}/issues"
    body = "\n".join(
        [
            "## Auto-created TODO",
            "",
            f"- Type: `{todo.type}`",
            f"- Source: `{todo.file}:{todo.line}`",
            f"- Priority: `{todo.priority}`",
            "",
            "### TODO text",
            todo.text or "(No text provided)",
            "",
            "### Context",
            "```text",
            todo.context or "(No context captured)",
            "```",
            "",
            marker,
            "",
            "_This issue was generated automatically from `build/scripts/docs/scan-todos.py`._",
        ]
    )
    created = gh_request(
        "POST",
        url,
        token,
        {"title": compact_title(todo), "body": body, "labels": [label]},
    )
    return int(created["number"])


def main() -> int:
    args = parse_args()

    if not args.scan_json.exists():
        print(f"Error: scan json not found: {args.scan_json}", file=sys.stderr)
        return 2

    if not args.dry_run and (not args.repo or not args.token):
        print("Error: --repo and --token (or env vars) are required unless --dry-run is used", file=sys.stderr)
        return 2

    todos = load_todos(args.scan_json)
    untracked = [todo for todo in todos if not todo.has_issue]

    if not untracked:
        print("No untracked TODO items found.")
        return 0

    if not args.dry_run:
        ensure_label(args.repo, args.token, args.label, dry_run=False)

    created = 0
    skipped = 0
    for todo in untracked:
        if created >= args.max_issues:
            skipped += 1
            continue

        try:
            number = create_issue(args.repo, args.token, todo, args.label, args.dry_run)
        except urllib.error.HTTPError as exc:
            print(f"Failed to create issue for {todo.file}:{todo.line}: HTTP {exc.code}", file=sys.stderr)
            skipped += 1
            continue

        if args.dry_run:
            print(f"[dry-run] would create issue for {todo.file}:{todo.line} :: {todo.text}")
            created += 1
        elif number is not None:
            print(f"Issue #{number} tracked for {todo.file}:{todo.line}")
            created += 1
        else:
            skipped += 1

    print(f"TODO issue creation complete: created={created}, skipped={skipped}, total_untracked={len(untracked)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
