#!/usr/bin/env python3
"""Create GitHub issues for untracked TODO items.

Consumes JSON generated by `scan-todos.py` and creates issues for TODO entries
that do not already reference an issue number.
"""

from __future__ import annotations

import argparse
import json
import os
import re
import sys
import urllib.error
import urllib.parse
import urllib.request
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any


DEFAULT_LABEL = "auto-todo"
MAX_TITLE_LENGTH = 120


@dataclass
class TodoItem:
    type: str
    text: str
    file: str
    line: int
    has_issue: bool
    issue_refs: list[str]
    priority: str
    context: str = ""


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Create GitHub issues for untracked TODO items")
    parser.add_argument("--scan-json", type=Path, required=True, help="Path to scan-todos JSON output")
    parser.add_argument("--repo", default=os.getenv("GITHUB_REPOSITORY", ""), help="owner/repo")
    parser.add_argument("--token", default=os.getenv("GITHUB_TOKEN") or os.getenv("GH_TOKEN", ""), help="GitHub token")
    parser.add_argument("--label", default=DEFAULT_LABEL, help="Label to add to created issues")
    parser.add_argument("--max-issues", type=int, default=20, help="Maximum issues to create per run")
    parser.add_argument("--dry-run", action="store_true", help="Report what would be created")
    parser.add_argument("--output-json", type=Path, help="Optional JSON summary output path")
    return parser.parse_args()


def gh_request(method: str, url: str, token: str, payload: dict[str, Any] | None = None) -> Any:
    data = None
    if payload is not None:
        data = json.dumps(payload).encode("utf-8")

    req = urllib.request.Request(url=url, method=method, data=data)
    req.add_header("Accept", "application/vnd.github+json")
    req.add_header("X-GitHub-Api-Version", "2022-11-28")
    req.add_header("User-Agent", "market-data-collector-docs-bot")
    req.add_header("Authorization", f"Bearer {token}")
    if data is not None:
        req.add_header("Content-Type", "application/json")

    try:
        with urllib.request.urlopen(req, timeout=30) as response:
            body = response.read().decode("utf-8")
            if not body.strip():
                return {}
            return json.loads(body)
    except urllib.error.HTTPError:
        raise
    except urllib.error.URLError as exc:
        raise RuntimeError(f"Network error while calling GitHub API: {exc}") from exc
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"Invalid JSON received from GitHub API for URL: {url}") from exc


def load_todos(path: Path) -> list[TodoItem]:
    try:
        payload = json.loads(path.read_text(encoding="utf-8"))
    except OSError as exc:
        raise ValueError(f"Failed to read scan file: {path}") from exc
    except json.JSONDecodeError as exc:
        raise ValueError(f"Invalid JSON in scan file: {path}") from exc

    if not isinstance(payload, dict):
        raise ValueError("Scan JSON root must be an object")

    raw_todos = payload.get("todos", [])
    if not isinstance(raw_todos, list):
        raise ValueError("Scan JSON field 'todos' must be a list")

    items = []
    for raw in payload.get("todos", []):
        items.append(
            TodoItem(
                type=str(raw.get("type", "TODO")),
                text=str(raw.get("text", "")).strip(),
                file=str(raw.get("file", "")),
                line=int(raw.get("line", 0)),
                has_issue=bool(raw.get("has_issue", False)),
                issue_refs=[str(v) for v in raw.get("issue_refs", [])],
                priority=str(raw.get("priority", "normal")),
                context=str(raw.get("context", "")),
            )
        )
    return items


def fingerprint(todo: TodoItem) -> str:
    return f"TODO-SOURCE: {todo.file}:{todo.line}"


def compact_title(todo: TodoItem) -> str:
    summary = re.sub(r"\s+", " ", todo.text).strip() or f"Review {todo.type} in {todo.file}:{todo.line}"
    prefix = f"[{todo.type}] "
    max_summary = max(16, MAX_TITLE_LENGTH - len(prefix))
    if len(summary) > max_summary:
        summary = summary[: max_summary - 3].rstrip() + "..."
    return f"{prefix}{summary}"


def ensure_label(repo: str, token: str, label: str, dry_run: bool) -> None:
    if dry_run:
        return
    url = f"https://api.github.com/repos/{repo}/labels/{urllib.parse.quote(label)}"
    try:
        gh_request("GET", url, token)
        return
    except urllib.error.HTTPError as exc:
        if exc.code != 404:
            raise

    create_url = f"https://api.github.com/repos/{repo}/labels"
    gh_request("POST", create_url, token, {"name": label, "color": "0e8a16", "description": "Auto-created from TODO scanner"})


def find_existing_issue(repo: str, token: str, marker: str) -> int | None:
    query = urllib.parse.quote(f'repo:{repo} "{marker}" in:body')
    url = f"https://api.github.com/search/issues?q={query}&per_page=1"
    try:
        result = gh_request("GET", url, token)
    except urllib.error.HTTPError:
        return None

    items = result.get("items", [])
    if not items:
        return None
    return int(items[0].get("number"))


def create_issue(repo: str, token: str, todo: TodoItem, label: str, dry_run: bool) -> tuple[str, int | None]:
    marker = fingerprint(todo)
    existing = find_existing_issue(repo, token, marker) if token and repo else None
    if existing is not None:
        return ("existing", existing)

    if dry_run:
        return ("dry-run", None)

    url = f"https://api.github.com/repos/{repo}/issues"
    body = "\n".join(
        [
            "## Auto-created TODO",
            "",
            f"- Type: `{todo.type}`",
            f"- Source: `{todo.file}:{todo.line}`",
            f"- Priority: `{todo.priority}`",
            "",
            "### TODO text",
            todo.text or "(No text provided)",
            "",
            "### Context",
            "```text",
            todo.context or "(No context captured)",
            "```",
            "",
            marker,
            "",
            "_This issue was generated automatically from `build/scripts/docs/scan-todos.py`._",
        ]
    )
    created = gh_request(
        "POST",
        url,
        token,
        {"title": compact_title(todo), "body": body, "labels": [label]},
    )
    return ("created", int(created["number"]))


def main() -> int:
    args = parse_args()

    if not args.scan_json.exists():
        print(f"Error: scan json not found: {args.scan_json}", file=sys.stderr)
        return 2

    if args.max_issues <= 0:
        print("Error: --max-issues must be greater than zero", file=sys.stderr)
        return 2

    if not args.dry_run and (not args.repo or not args.token):
        print("Error: --repo and --token (or env vars) are required unless --dry-run is used", file=sys.stderr)
        return 2

    try:
        todos = load_todos(args.scan_json)
    except ValueError as exc:
        print(f"Error: {exc}", file=sys.stderr)
        return 2
    untracked = [todo for todo in todos if not todo.has_issue]

    if not untracked:
        print("No untracked TODO items found.")
        return 0

    if not args.dry_run:
        ensure_label(args.repo, args.token, args.label, dry_run=False)

    created = 0
    existing = 0
    failed = 0
    skipped_limit = 0

    for todo in untracked:
        if created >= args.max_issues:
            skipped_limit += 1
            continue

        try:
            outcome, number = create_issue(args.repo, args.token, todo, args.label, args.dry_run)
        except urllib.error.HTTPError as exc:
            print(f"Failed to create issue for {todo.file}:{todo.line}: HTTP {exc.code}", file=sys.stderr)
            failed += 1
            continue
        except RuntimeError as exc:
            print(f"Failed to create issue for {todo.file}:{todo.line}: {exc}", file=sys.stderr)
            failed += 1
            continue

        if outcome == "existing":
            existing += 1
            print(f"Existing issue #{number} already tracks {todo.file}:{todo.line}")
            continue

        if outcome == "dry-run":
            print(f"[dry-run] would create issue for {todo.file}:{todo.line} :: {todo.text}")
            created += 1
            continue

        if outcome == "created":
            print(f"Issue #{number} tracked for {todo.file}:{todo.line}")
            created += 1
            continue

        failed += 1

    summary = {
        "created": created,
        "existing": existing,
        "failed": failed,
        "skipped_limit": skipped_limit,
        "total_untracked": len(untracked),
        "dry_run": args.dry_run,
        "repo": args.repo,
        "label": args.label,
        "generated_at": datetime.now(timezone.utc).isoformat(),
    }

    if args.output_json:
        args.output_json.parent.mkdir(parents=True, exist_ok=True)
        args.output_json.write_text(json.dumps(summary, indent=2) + "\n", encoding="utf-8")

    print(
        "TODO issue creation complete: "
        f"created={created}, existing={existing}, failed={failed}, "
        f"skipped_limit={skipped_limit}, total_untracked={len(untracked)}"
    )
    return 1 if failed > 0 else 0


if __name__ == "__main__":
    raise SystemExit(main())
