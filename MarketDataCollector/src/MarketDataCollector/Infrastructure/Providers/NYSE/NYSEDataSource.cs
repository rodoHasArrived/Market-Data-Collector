using System.Collections.Concurrent;
using System.Net.Http.Headers;
using System.Net.WebSockets;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using MarketDataCollector.Application.Config;
using MarketDataCollector.Application.Logging;
using MarketDataCollector.Domain.Models;
using MarketDataCollector.Infrastructure.DataSources;
using DataSourceType = MarketDataCollector.Infrastructure.DataSources.DataSourceType;
using MarketDataCollector.Infrastructure.Providers.Backfill;
using Serilog;

namespace MarketDataCollector.Infrastructure.Providers.NYSE;

/// <summary>
/// NYSE Direct Connection data source providing real-time and historical market data
/// directly from the New York Stock Exchange.
///
/// Features:
/// - Real-time trades and quotes via NYSE Integrated Feed
/// - Historical daily OHLCV bars via NYSE Historical Data API
/// - Level 2 market depth (Premium/Professional tiers)
/// - Trade conditions and participant IDs
/// - Pre-market and after-hours data
/// - Corporate actions (dividends, splits)
///
/// Requires NYSE Connect API credentials and appropriate data subscriptions.
/// </summary>
[DataSource(
    id: "nyse",
    displayName: "NYSE Direct",
    type: DataSourceType.Hybrid,
    category: DataSourceCategory.Exchange,
    Priority = 5,
    Description = "Direct connection to NYSE for real-time and historical US equity data")]
public sealed class NYSEDataSource : DataSourceBase, IRealtimeDataSource, IHistoricalDataSource
{
    #region Fields

    private readonly NYSEOptions _options;
    private readonly HttpClient _httpClient;
    private ClientWebSocket? _webSocket;
    private CancellationTokenSource? _connectionCts;
    private Task? _receiveTask;

    private readonly Subject<RealtimeTrade> _trades = new();
    private readonly Subject<RealtimeQuote> _quotes = new();
    private readonly Subject<RealtimeDepthUpdate> _depthUpdates = new();

    private readonly ConcurrentDictionary<int, SubscriptionInfo> _subscriptions = new();
    private readonly ConcurrentDictionary<string, int> _symbolToSubId = new();
    private int _nextSubscriptionId = 1;

    private string? _accessToken;
    private DateTimeOffset _tokenExpiry = DateTimeOffset.MinValue;
    private readonly SemaphoreSlim _authLock = new(1, 1);

    private static readonly HashSet<string> SupportedMarketsSet = new(StringComparer.OrdinalIgnoreCase) { "US" };
    private static readonly HashSet<AssetClass> SupportedAssetClassesSet = new()
    {
        AssetClass.Equity,
        AssetClass.ETF,
        AssetClass.Index
    };

    private static readonly string[] BarIntervalsArray = { "1Min", "5Min", "15Min", "30Min", "1Hour", "1Day" };

    #endregion

    #region Identity

    public override string Id => "nyse";
    public override string DisplayName => "NYSE Direct";
    public override string Description => "Direct connection to NYSE for real-time and historical US equity data";

    #endregion

    #region Classification

    public override DataSourceType Type => DataSourceType.Hybrid;
    public override DataSourceCategory Category => DataSourceCategory.Exchange;

    #endregion

    #region Capabilities

    public override DataSourceCapabilities Capabilities =>
        DataSourceCapabilities.RealtimeTrades |
        DataSourceCapabilities.RealtimeQuotes |
        DataSourceCapabilities.RealtimeDepthL1 |
        (_options.EnableLevel2 ? DataSourceCapabilities.RealtimeDepthL2 : 0) |
        DataSourceCapabilities.HistoricalDailyBars |
        DataSourceCapabilities.HistoricalIntradayBars |
        DataSourceCapabilities.HistoricalAdjustedPrices |
        DataSourceCapabilities.HistoricalDividends |
        DataSourceCapabilities.HistoricalSplits |
        DataSourceCapabilities.SupportsBackfill |
        DataSourceCapabilities.SupportsStreaming |
        DataSourceCapabilities.SupportsWebSocket |
        DataSourceCapabilities.SupportsBatchRequests |
        DataSourceCapabilities.SupportsSymbolSearch |
        DataSourceCapabilities.SupportsMultiSubscription |
        DataSourceCapabilities.ExchangeTimestamps |
        DataSourceCapabilities.SequenceNumbers |
        DataSourceCapabilities.TradeConditions |
        DataSourceCapabilities.ParticipantIds |
        DataSourceCapabilities.ConsolidatedTape;

    public override DataSourceCapabilityInfo CapabilityInfo => new(
        Capabilities,
        MinHistoricalDate: new DateOnly(1990, 1, 1),
        MaxHistoricalLookback: TimeSpan.FromDays(365 * 35),
        MaxSymbolsPerSubscription: _options.MaxSubscriptions,
        MaxDepthLevels: _options.FeedTier >= NYSEFeedTier.Premium ? 10 : 1,
        MinBarResolution: TimeSpan.FromMinutes(1),
        SupportedBarIntervals: BarIntervalsArray,
        MaxRequestsPerMinute: 100,
        MaxRequestsPerHour: 5000,
        MaxRequestsPerDay: 50000
    );

    public override IReadOnlySet<string> SupportedMarkets => SupportedMarketsSet;
    public override IReadOnlySet<AssetClass> SupportedAssetClasses => SupportedAssetClassesSet;

    #endregion

    #region Constructor

    public NYSEDataSource(
        NYSEOptions options,
        DataSourceOptions? sourceOptions = null,
        ILogger? logger = null)
        : base(sourceOptions ?? DataSourceOptions.Default, logger)
    {
        _options = options ?? throw new ArgumentNullException(nameof(options));

        _httpClient = new HttpClient
        {
            BaseAddress = new Uri(_options.EffectiveBaseUrl),
            Timeout = TimeSpan.FromSeconds(_options.ConnectionTimeoutSeconds)
        };
        _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
    }

    #endregion

    #region Lifecycle

    public override async Task<bool> ValidateCredentialsAsync(CancellationToken ct = default)
    {
        var apiKey = _options.ResolveApiKey();
        var apiSecret = _options.ResolveApiSecret();

        if (string.IsNullOrWhiteSpace(apiKey) || string.IsNullOrWhiteSpace(apiSecret))
        {
            Log.Warning("NYSE credentials not configured. Set NYSE_API_KEY and NYSE_API_SECRET environment variables.");
            return false;
        }

        try
        {
            // Try to obtain an access token to validate credentials
            await EnsureAuthenticatedAsync(ct).ConfigureAwait(false);
            return !string.IsNullOrEmpty(_accessToken);
        }
        catch (Exception ex)
        {
            Log.Error(ex, "NYSE credential validation failed");
            return false;
        }
    }

    public override async Task<bool> TestConnectivityAsync(CancellationToken ct = default)
    {
        try
        {
            await EnsureAuthenticatedAsync(ct).ConfigureAwait(false);

            // Test REST API connectivity
            using var request = new HttpRequestMessage(HttpMethod.Get, "/markets/status");
            AddAuthHeader(request);

            using var response = await _httpClient.SendAsync(request, ct).ConfigureAwait(false);
            return response.IsSuccessStatusCode;
        }
        catch (Exception ex)
        {
            Log.Error(ex, "NYSE connectivity test failed");
            return false;
        }
    }

    protected override async ValueTask OnDisposeAsync()
    {
        await DisconnectAsync().ConfigureAwait(false);

        _trades.OnCompleted();
        _trades.Dispose();
        _quotes.OnCompleted();
        _quotes.Dispose();
        _depthUpdates.OnCompleted();
        _depthUpdates.Dispose();

        _authLock.Dispose();
        _httpClient.Dispose();
    }

    #endregion

    #region Connection (Real-time)

    public bool IsConnected => _webSocket?.State == WebSocketState.Open;

    public async Task ConnectAsync(CancellationToken ct = default)
    {
        if (IsConnected)
        {
            Log.Debug("NYSE WebSocket already connected");
            return;
        }

        await EnsureAuthenticatedAsync(ct).ConfigureAwait(false);

        Log.Information("Connecting to NYSE WebSocket at {Url}", _options.EffectiveWebSocketUrl);

        _connectionCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        _webSocket = new ClientWebSocket();

        // Add authentication to WebSocket
        _webSocket.Options.SetRequestHeader("Authorization", $"Bearer {_accessToken}");

        try
        {
            await _webSocket.ConnectAsync(new Uri(_options.EffectiveWebSocketUrl), _connectionCts.Token)
                .ConfigureAwait(false);

            Status = DataSourceStatus.Connected;
            Log.Information("Connected to NYSE WebSocket");

            // Start receiving messages
            _receiveTask = ReceiveMessagesAsync(_connectionCts.Token);

            // Re-subscribe to any existing subscriptions
            await ResubscribeAllAsync(_connectionCts.Token).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            Status = DataSourceStatus.Disconnected;
            Log.Error(ex, "Failed to connect to NYSE WebSocket");
            throw;
        }
    }

    public async Task DisconnectAsync(CancellationToken ct = default)
    {
        if (_webSocket == null) return;

        Log.Information("Disconnecting from NYSE WebSocket");

        try
        {
            _connectionCts?.Cancel();

            if (_webSocket.State == WebSocketState.Open)
            {
                await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Disconnecting", ct)
                    .ConfigureAwait(false);
            }

            if (_receiveTask != null)
            {
                try { await _receiveTask.ConfigureAwait(false); }
                catch (OperationCanceledException) { }
            }
        }
        catch (Exception ex)
        {
            Log.Warning(ex, "Error during NYSE WebSocket disconnect");
        }
        finally
        {
            _webSocket?.Dispose();
            _webSocket = null;
            _connectionCts?.Dispose();
            _connectionCts = null;
            Status = DataSourceStatus.Disconnected;
        }
    }

    #endregion

    #region Trade Subscriptions

    public IObservable<RealtimeTrade> Trades => _trades.AsObservable();

    public int SubscribeTrades(SymbolConfig config)
    {
        var subId = GetOrCreateSubscription(config, SubscriptionType.Trades);

        if (IsConnected)
        {
            _ = SendSubscriptionMessageAsync(config.Symbol, "trades", "subscribe");
        }

        return subId;
    }

    public void UnsubscribeTrades(int subscriptionId)
    {
        if (_subscriptions.TryRemove(subscriptionId, out var info))
        {
            _symbolToSubId.TryRemove(info.Symbol + "_trades", out _);

            if (IsConnected)
            {
                _ = SendSubscriptionMessageAsync(info.Symbol, "trades", "unsubscribe");
            }
        }
    }

    #endregion

    #region Quote Subscriptions

    public IObservable<RealtimeQuote> Quotes => _quotes.AsObservable();

    public int SubscribeQuotes(SymbolConfig config)
    {
        var subId = GetOrCreateSubscription(config, SubscriptionType.Quotes);

        if (IsConnected)
        {
            _ = SendSubscriptionMessageAsync(config.Symbol, "quotes", "subscribe");
        }

        return subId;
    }

    public void UnsubscribeQuotes(int subscriptionId)
    {
        if (_subscriptions.TryRemove(subscriptionId, out var info))
        {
            _symbolToSubId.TryRemove(info.Symbol + "_quotes", out _);

            if (IsConnected)
            {
                _ = SendSubscriptionMessageAsync(info.Symbol, "quotes", "unsubscribe");
            }
        }
    }

    #endregion

    #region Depth Subscriptions

    public IObservable<RealtimeDepthUpdate> DepthUpdates => _depthUpdates.AsObservable();

    public int SubscribeMarketDepth(SymbolConfig config)
    {
        if (_options.FeedTier < NYSEFeedTier.Premium)
        {
            Log.Warning("NYSE Level 2 depth requires Premium or Professional feed tier");
        }

        var subId = GetOrCreateSubscription(config, SubscriptionType.Depth);

        if (IsConnected)
        {
            _ = SendSubscriptionMessageAsync(config.Symbol, "depth", "subscribe");
        }

        return subId;
    }

    public void UnsubscribeMarketDepth(int subscriptionId)
    {
        if (_subscriptions.TryRemove(subscriptionId, out var info))
        {
            _symbolToSubId.TryRemove(info.Symbol + "_depth", out _);

            if (IsConnected)
            {
                _ = SendSubscriptionMessageAsync(info.Symbol, "depth", "unsubscribe");
            }
        }
    }

    #endregion

    #region Active Subscriptions

    public IReadOnlySet<int> ActiveSubscriptions =>
        new HashSet<int>(_subscriptions.Keys);

    public IReadOnlySet<string> SubscribedSymbols =>
        new HashSet<string>(_subscriptions.Values.Select(s => s.Symbol));

    public void UnsubscribeAll()
    {
        var allSubs = _subscriptions.Keys.ToList();
        foreach (var subId in allSubs)
        {
            if (_subscriptions.TryRemove(subId, out var info))
            {
                _symbolToSubId.TryRemove($"{info.Symbol}_{info.Type.ToString().ToLowerInvariant()}", out _);
            }
        }

        if (IsConnected)
        {
            _ = SendUnsubscribeAllMessageAsync();
        }
    }

    #endregion

    #region Historical Data

    public bool SupportsIntraday => true;
    public IReadOnlyList<string> SupportedBarIntervals => BarIntervalsArray;
    public bool SupportsDividends => true;
    public bool SupportsSplits => true;

    public async Task<IReadOnlyList<HistoricalBar>> GetDailyBarsAsync(
        string symbol,
        DateOnly? from = null,
        DateOnly? to = null,
        CancellationToken ct = default)
    {
        var adjusted = await GetAdjustedDailyBarsAsync(symbol, from, to, ct).ConfigureAwait(false);
        return adjusted.Select(b => b.ToHistoricalBar(preferAdjusted: false)).ToList();
    }

    public async Task<IReadOnlyList<AdjustedHistoricalBar>> GetAdjustedDailyBarsAsync(
        string symbol,
        DateOnly? from = null,
        DateOnly? to = null,
        CancellationToken ct = default)
    {
        return await ExecuteWithPoliciesAsync(async token =>
        {
            await EnsureAuthenticatedAsync(token).ConfigureAwait(false);

            var fromDate = from ?? DateOnly.FromDateTime(DateTime.UtcNow.AddYears(-1));
            var toDate = to ?? DateOnly.FromDateTime(DateTime.UtcNow);

            var url = $"/historical/bars/{symbol}?from={fromDate:yyyy-MM-dd}&to={toDate:yyyy-MM-dd}&adjusted=true";

            using var request = new HttpRequestMessage(HttpMethod.Get, url);
            AddAuthHeader(request);

            using var response = await _httpClient.SendAsync(request, token).ConfigureAwait(false);
            response.EnsureSuccessStatusCode();

            var json = await response.Content.ReadAsStringAsync(token).ConfigureAwait(false);
            var data = JsonSerializer.Deserialize<NYSEHistoricalBarsResponse>(json);

            if (data?.Bars == null || data.Bars.Count == 0)
            {
                Log.Information("No historical bars returned from NYSE for {Symbol}", symbol);
                return Array.Empty<AdjustedHistoricalBar>();
            }

            var bars = new List<AdjustedHistoricalBar>();

            foreach (var bar in data.Bars)
            {
                try
                {
                    bars.Add(new AdjustedHistoricalBar(
                        Symbol: symbol.ToUpperInvariant(),
                        SessionDate: DateOnly.Parse(bar.Date),
                        Open: bar.Open,
                        High: bar.High,
                        Low: bar.Low,
                        Close: bar.Close,
                        Volume: bar.Volume,
                        Source: Id,
                        SequenceNumber: bar.SequenceNumber ?? 0,
                        AdjustedOpen: bar.AdjustedOpen,
                        AdjustedHigh: bar.AdjustedHigh,
                        AdjustedLow: bar.AdjustedLow,
                        AdjustedClose: bar.AdjustedClose,
                        AdjustedVolume: bar.AdjustedVolume,
                        SplitFactor: bar.SplitFactor,
                        DividendAmount: bar.DividendAmount
                    ));
                }
                catch (Exception ex)
                {
                    Log.Warning(ex, "Failed to parse NYSE bar for {Symbol} on {Date}", symbol, bar.Date);
                }
            }

            Log.Information("Fetched {Count} historical bars from NYSE for {Symbol}", bars.Count, symbol);
            return bars.OrderBy(b => b.SessionDate).ToArray();
        }, "GetAdjustedDailyBars", ct).ConfigureAwait(false);
    }

    public async Task<IReadOnlyList<IntradayBar>> GetIntradayBarsAsync(
        string symbol,
        string interval,
        DateTimeOffset? from = null,
        DateTimeOffset? to = null,
        CancellationToken ct = default)
    {
        return await ExecuteWithPoliciesAsync(async token =>
        {
            await EnsureAuthenticatedAsync(token).ConfigureAwait(false);

            var fromTime = from ?? DateTimeOffset.UtcNow.AddDays(-5);
            var toTime = to ?? DateTimeOffset.UtcNow;

            var url = $"/historical/intraday/{symbol}?from={fromTime:O}&to={toTime:O}&interval={interval}";

            using var request = new HttpRequestMessage(HttpMethod.Get, url);
            AddAuthHeader(request);

            using var response = await _httpClient.SendAsync(request, token).ConfigureAwait(false);
            response.EnsureSuccessStatusCode();

            var json = await response.Content.ReadAsStringAsync(token).ConfigureAwait(false);
            var data = JsonSerializer.Deserialize<NYSEIntradayBarsResponse>(json);

            if (data?.Bars == null || data.Bars.Count == 0)
            {
                return Array.Empty<IntradayBar>();
            }

            return data.Bars.Select(bar => new IntradayBar(
                Symbol: symbol.ToUpperInvariant(),
                Timestamp: DateTimeOffset.Parse(bar.Timestamp),
                Interval: interval,
                Open: bar.Open,
                High: bar.High,
                Low: bar.Low,
                Close: bar.Close,
                Volume: bar.Volume,
                Source: Id,
                TradeCount: bar.TradeCount,
                VWAP: bar.Vwap
            )).OrderBy(b => b.Timestamp).ToArray();
        }, "GetIntradayBars", ct).ConfigureAwait(false);
    }

    public async Task<IReadOnlyList<DividendInfo>> GetDividendsAsync(
        string symbol,
        DateOnly? from = null,
        DateOnly? to = null,
        CancellationToken ct = default)
    {
        return await ExecuteWithPoliciesAsync(async token =>
        {
            await EnsureAuthenticatedAsync(token).ConfigureAwait(false);

            var fromDate = from ?? DateOnly.FromDateTime(DateTime.UtcNow.AddYears(-5));
            var toDate = to ?? DateOnly.FromDateTime(DateTime.UtcNow);

            var url = $"/corporate-actions/dividends/{symbol}?from={fromDate:yyyy-MM-dd}&to={toDate:yyyy-MM-dd}";

            using var request = new HttpRequestMessage(HttpMethod.Get, url);
            AddAuthHeader(request);

            using var response = await _httpClient.SendAsync(request, token).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                Log.Warning("NYSE returned {Status} for dividends request for {Symbol}", response.StatusCode, symbol);
                return Array.Empty<DividendInfo>();
            }

            var json = await response.Content.ReadAsStringAsync(token).ConfigureAwait(false);
            var data = JsonSerializer.Deserialize<NYSEDividendsResponse>(json);

            if (data?.Dividends == null || data.Dividends.Count == 0)
            {
                return Array.Empty<DividendInfo>();
            }

            return data.Dividends.Select(div => new DividendInfo(
                Symbol: symbol.ToUpperInvariant(),
                ExDate: DateOnly.Parse(div.ExDate),
                PaymentDate: !string.IsNullOrEmpty(div.PaymentDate) ? DateOnly.Parse(div.PaymentDate) : null,
                RecordDate: !string.IsNullOrEmpty(div.RecordDate) ? DateOnly.Parse(div.RecordDate) : null,
                Amount: div.Amount,
                Currency: div.Currency ?? "USD",
                Type: ParseDividendType(div.Type),
                Source: Id
            )).OrderBy(d => d.ExDate).ToArray();
        }, "GetDividends", ct).ConfigureAwait(false);
    }

    public async Task<IReadOnlyList<SplitInfo>> GetSplitsAsync(
        string symbol,
        DateOnly? from = null,
        DateOnly? to = null,
        CancellationToken ct = default)
    {
        return await ExecuteWithPoliciesAsync(async token =>
        {
            await EnsureAuthenticatedAsync(token).ConfigureAwait(false);

            var fromDate = from ?? DateOnly.FromDateTime(DateTime.UtcNow.AddYears(-10));
            var toDate = to ?? DateOnly.FromDateTime(DateTime.UtcNow);

            var url = $"/corporate-actions/splits/{symbol}?from={fromDate:yyyy-MM-dd}&to={toDate:yyyy-MM-dd}";

            using var request = new HttpRequestMessage(HttpMethod.Get, url);
            AddAuthHeader(request);

            using var response = await _httpClient.SendAsync(request, token).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                Log.Warning("NYSE returned {Status} for splits request for {Symbol}", response.StatusCode, symbol);
                return Array.Empty<SplitInfo>();
            }

            var json = await response.Content.ReadAsStringAsync(token).ConfigureAwait(false);
            var data = JsonSerializer.Deserialize<NYSESplitsResponse>(json);

            if (data?.Splits == null || data.Splits.Count == 0)
            {
                return Array.Empty<SplitInfo>();
            }

            return data.Splits.Select(split => new SplitInfo(
                Symbol: symbol.ToUpperInvariant(),
                ExDate: DateOnly.Parse(split.ExDate),
                SplitFrom: split.SplitFrom,
                SplitTo: split.SplitTo,
                Source: Id
            )).OrderBy(s => s.ExDate).ToArray();
        }, "GetSplits", ct).ConfigureAwait(false);
    }

    #endregion

    #region Authentication

    private async Task EnsureAuthenticatedAsync(CancellationToken ct)
    {
        if (!string.IsNullOrEmpty(_accessToken) && DateTimeOffset.UtcNow < _tokenExpiry.AddMinutes(-5))
        {
            return;
        }

        await _authLock.WaitAsync(ct).ConfigureAwait(false);
        try
        {
            if (!string.IsNullOrEmpty(_accessToken) && DateTimeOffset.UtcNow < _tokenExpiry.AddMinutes(-5))
            {
                return;
            }

            var apiKey = _options.ResolveApiKey();
            var apiSecret = _options.ResolveApiSecret();

            if (string.IsNullOrEmpty(apiKey) || string.IsNullOrEmpty(apiSecret))
            {
                throw new InvalidOperationException("NYSE API credentials not configured");
            }

            // OAuth2 client credentials flow
            var authContent = new FormUrlEncodedContent(new Dictionary<string, string>
            {
                ["grant_type"] = "client_credentials",
                ["client_id"] = _options.ResolveClientId() ?? apiKey,
                ["client_secret"] = apiSecret
            });

            using var authRequest = new HttpRequestMessage(HttpMethod.Post, "/oauth/token")
            {
                Content = authContent
            };

            using var response = await _httpClient.SendAsync(authRequest, ct).ConfigureAwait(false);
            response.EnsureSuccessStatusCode();

            var json = await response.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
            var tokenResponse = JsonSerializer.Deserialize<NYSETokenResponse>(json);

            _accessToken = tokenResponse?.AccessToken
                ?? throw new InvalidOperationException("Failed to obtain NYSE access token");
            _tokenExpiry = DateTimeOffset.UtcNow.AddSeconds(tokenResponse.ExpiresIn);

            Log.Debug("Obtained NYSE access token, expires at {Expiry}", _tokenExpiry);
        }
        finally
        {
            _authLock.Release();
        }
    }

    private void AddAuthHeader(HttpRequestMessage request)
    {
        if (!string.IsNullOrEmpty(_accessToken))
        {
            request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", _accessToken);
        }
    }

    #endregion

    #region WebSocket Message Handling

    private async Task ReceiveMessagesAsync(CancellationToken ct)
    {
        var buffer = new byte[8192];

        try
        {
            while (_webSocket?.State == WebSocketState.Open && !ct.IsCancellationRequested)
            {
                var result = await _webSocket.ReceiveAsync(buffer, ct).ConfigureAwait(false);

                if (result.MessageType == WebSocketMessageType.Close)
                {
                    Log.Information("NYSE WebSocket closed by server");
                    break;
                }

                if (result.MessageType == WebSocketMessageType.Text)
                {
                    var message = Encoding.UTF8.GetString(buffer, 0, result.Count);
                    ProcessWebSocketMessage(message);
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Expected on disconnect
        }
        catch (WebSocketException ex)
        {
            Log.Error(ex, "NYSE WebSocket error");
            Status = DataSourceStatus.Disconnected;
            _ = TryReconnectAsync();
        }
    }

    private void ProcessWebSocketMessage(string message)
    {
        try
        {
            using var doc = JsonDocument.Parse(message);
            var root = doc.RootElement;

            var msgType = root.GetProperty("type").GetString();

            switch (msgType)
            {
                case "trade":
                    ProcessTradeMessage(root);
                    break;
                case "quote":
                    ProcessQuoteMessage(root);
                    break;
                case "depth":
                    ProcessDepthMessage(root);
                    break;
                case "heartbeat":
                    Log.Verbose("NYSE heartbeat received");
                    break;
                case "error":
                    var errorMsg = root.GetProperty("message").GetString();
                    Log.Error("NYSE WebSocket error: {Error}", errorMsg);
                    break;
            }
        }
        catch (Exception ex)
        {
            Log.Warning(ex, "Failed to process NYSE WebSocket message: {Message}", message);
        }
    }

    private void ProcessTradeMessage(JsonElement root)
    {
        var trade = new RealtimeTrade(
            Symbol: root.GetProperty("symbol").GetString() ?? "",
            Price: root.GetProperty("price").GetDecimal(),
            Size: root.GetProperty("size").GetInt64(),
            Timestamp: DateTimeOffset.Parse(root.GetProperty("timestamp").GetString() ?? ""),
            SourceId: Id,
            Exchange: root.TryGetProperty("exchange", out var ex) ? ex.GetString() : "NYSE",
            Conditions: root.TryGetProperty("conditions", out var cond) ? cond.GetString() : null,
            SequenceNumber: root.TryGetProperty("sequence", out var seq) ? seq.GetInt64() : null,
            Side: ParseAggressorSide(root.TryGetProperty("side", out var side) ? side.GetString() : null)
        );

        _trades.OnNext(trade);
    }

    private void ProcessQuoteMessage(JsonElement root)
    {
        var quote = new RealtimeQuote(
            Symbol: root.GetProperty("symbol").GetString() ?? "",
            BidPrice: root.GetProperty("bidPrice").GetDecimal(),
            BidSize: root.GetProperty("bidSize").GetInt64(),
            AskPrice: root.GetProperty("askPrice").GetDecimal(),
            AskSize: root.GetProperty("askSize").GetInt64(),
            Timestamp: DateTimeOffset.Parse(root.GetProperty("timestamp").GetString() ?? ""),
            SourceId: Id,
            BidExchange: root.TryGetProperty("bidExchange", out var bidEx) ? bidEx.GetString() : "NYSE",
            AskExchange: root.TryGetProperty("askExchange", out var askEx) ? askEx.GetString() : "NYSE",
            SequenceNumber: root.TryGetProperty("sequence", out var seq) ? seq.GetInt64() : null
        );

        _quotes.OnNext(quote);
    }

    private void ProcessDepthMessage(JsonElement root)
    {
        var update = new RealtimeDepthUpdate(
            Symbol: root.GetProperty("symbol").GetString() ?? "",
            Operation: ParseDepthOperation(root.GetProperty("operation").GetString()),
            Side: root.GetProperty("side").GetString()?.ToLowerInvariant() == "bid"
                ? OrderBookSide.Bid : OrderBookSide.Ask,
            Level: root.GetProperty("level").GetInt32(),
            Price: root.GetProperty("price").GetDecimal(),
            Size: root.GetProperty("size").GetInt64(),
            Timestamp: DateTimeOffset.Parse(root.GetProperty("timestamp").GetString() ?? ""),
            SourceId: Id,
            MarketMaker: root.TryGetProperty("marketMaker", out var mm) ? mm.GetString() : null,
            SequenceNumber: root.TryGetProperty("sequence", out var seq) ? seq.GetInt64() : null
        );

        _depthUpdates.OnNext(update);
    }

    private async Task SendSubscriptionMessageAsync(string symbol, string channel, string action)
    {
        if (_webSocket?.State != WebSocketState.Open) return;

        var message = JsonSerializer.Serialize(new
        {
            action,
            channel,
            symbol
        });

        var bytes = Encoding.UTF8.GetBytes(message);
        await _webSocket.SendAsync(bytes, WebSocketMessageType.Text, true, CancellationToken.None)
            .ConfigureAwait(false);

        Log.Debug("NYSE {Action} {Channel} for {Symbol}", action, channel, symbol);
    }

    private async Task SendUnsubscribeAllMessageAsync()
    {
        if (_webSocket?.State != WebSocketState.Open) return;

        var message = JsonSerializer.Serialize(new { action = "unsubscribe_all" });
        var bytes = Encoding.UTF8.GetBytes(message);
        await _webSocket.SendAsync(bytes, WebSocketMessageType.Text, true, CancellationToken.None)
            .ConfigureAwait(false);
    }

    private async Task ResubscribeAllAsync(CancellationToken ct)
    {
        foreach (var (_, info) in _subscriptions)
        {
            var channel = info.Type.ToString().ToLowerInvariant();
            await SendSubscriptionMessageAsync(info.Symbol, channel, "subscribe").ConfigureAwait(false);
        }
    }

    private async Task TryReconnectAsync()
    {
        for (int attempt = 1; attempt <= _options.MaxReconnectAttempts; attempt++)
        {
            Log.Information("NYSE reconnection attempt {Attempt}/{Max}", attempt, _options.MaxReconnectAttempts);

            await Task.Delay(TimeSpan.FromSeconds(_options.ReconnectDelaySeconds * attempt))
                .ConfigureAwait(false);

            try
            {
                await ConnectAsync().ConfigureAwait(false);
                return;
            }
            catch (Exception ex)
            {
                Log.Warning(ex, "NYSE reconnection attempt {Attempt} failed", attempt);
            }
        }

        Log.Error("NYSE failed to reconnect after {Max} attempts", _options.MaxReconnectAttempts);
        Status = DataSourceStatus.Unavailable;
    }

    #endregion

    #region Subscription Helpers

    private int GetOrCreateSubscription(SymbolConfig config, SubscriptionType type)
    {
        var key = $"{config.Symbol}_{type.ToString().ToLowerInvariant()}";

        if (_symbolToSubId.TryGetValue(key, out var existingId))
        {
            return existingId;
        }

        var subId = Interlocked.Increment(ref _nextSubscriptionId);
        var info = new SubscriptionInfo(config.Symbol, type, DateTimeOffset.UtcNow);

        _subscriptions[subId] = info;
        _symbolToSubId[key] = subId;

        return subId;
    }

    private static AggressorSide ParseAggressorSide(string? side) => side?.ToLowerInvariant() switch
    {
        "buy" => AggressorSide.Buy,
        "sell" => AggressorSide.Sell,
        _ => AggressorSide.Unknown
    };

    private static DepthOperation ParseDepthOperation(string? operation) => operation?.ToLowerInvariant() switch
    {
        "add" or "insert" => DepthOperation.Insert,
        "update" or "modify" => DepthOperation.Update,
        "delete" or "remove" => DepthOperation.Delete,
        _ => DepthOperation.Insert // Default to Insert for unrecognized operations
    };

    private static DividendType ParseDividendType(string? type) => type?.ToLowerInvariant() switch
    {
        "special" => DividendType.Special,
        "return" => DividendType.Return,
        "liquidation" => DividendType.Liquidation,
        _ => DividendType.Regular
    };

    #endregion

    #region Internal Types

    private enum SubscriptionType { Trades, Quotes, Depth }

    private sealed record SubscriptionInfo(string Symbol, SubscriptionType Type, DateTimeOffset CreatedAt);

    #endregion
}

#region NYSE API Response Models

internal sealed class NYSETokenResponse
{
    [JsonPropertyName("access_token")]
    public string? AccessToken { get; set; }

    [JsonPropertyName("token_type")]
    public string? TokenType { get; set; }

    [JsonPropertyName("expires_in")]
    public int ExpiresIn { get; set; }
}

internal sealed class NYSEHistoricalBarsResponse
{
    [JsonPropertyName("bars")]
    public List<NYSEHistoricalBar>? Bars { get; set; }
}

internal sealed class NYSEHistoricalBar
{
    [JsonPropertyName("date")]
    public string Date { get; set; } = "";

    [JsonPropertyName("open")]
    public decimal Open { get; set; }

    [JsonPropertyName("high")]
    public decimal High { get; set; }

    [JsonPropertyName("low")]
    public decimal Low { get; set; }

    [JsonPropertyName("close")]
    public decimal Close { get; set; }

    [JsonPropertyName("volume")]
    public long Volume { get; set; }

    [JsonPropertyName("adjustedOpen")]
    public decimal? AdjustedOpen { get; set; }

    [JsonPropertyName("adjustedHigh")]
    public decimal? AdjustedHigh { get; set; }

    [JsonPropertyName("adjustedLow")]
    public decimal? AdjustedLow { get; set; }

    [JsonPropertyName("adjustedClose")]
    public decimal? AdjustedClose { get; set; }

    [JsonPropertyName("adjustedVolume")]
    public long? AdjustedVolume { get; set; }

    [JsonPropertyName("splitFactor")]
    public decimal? SplitFactor { get; set; }

    [JsonPropertyName("dividendAmount")]
    public decimal? DividendAmount { get; set; }

    [JsonPropertyName("sequenceNumber")]
    public long? SequenceNumber { get; set; }
}

internal sealed class NYSEIntradayBarsResponse
{
    [JsonPropertyName("bars")]
    public List<NYSEIntradayBar>? Bars { get; set; }
}

internal sealed class NYSEIntradayBar
{
    [JsonPropertyName("timestamp")]
    public string Timestamp { get; set; } = "";

    [JsonPropertyName("open")]
    public decimal Open { get; set; }

    [JsonPropertyName("high")]
    public decimal High { get; set; }

    [JsonPropertyName("low")]
    public decimal Low { get; set; }

    [JsonPropertyName("close")]
    public decimal Close { get; set; }

    [JsonPropertyName("volume")]
    public long Volume { get; set; }

    [JsonPropertyName("tradeCount")]
    public long? TradeCount { get; set; }

    [JsonPropertyName("vwap")]
    public decimal? Vwap { get; set; }
}

internal sealed class NYSEDividendsResponse
{
    [JsonPropertyName("dividends")]
    public List<NYSEDividend>? Dividends { get; set; }
}

internal sealed class NYSEDividend
{
    [JsonPropertyName("exDate")]
    public string ExDate { get; set; } = "";

    [JsonPropertyName("paymentDate")]
    public string? PaymentDate { get; set; }

    [JsonPropertyName("recordDate")]
    public string? RecordDate { get; set; }

    [JsonPropertyName("amount")]
    public decimal Amount { get; set; }

    [JsonPropertyName("currency")]
    public string? Currency { get; set; }

    [JsonPropertyName("type")]
    public string? Type { get; set; }
}

internal sealed class NYSESplitsResponse
{
    [JsonPropertyName("splits")]
    public List<NYSESplit>? Splits { get; set; }
}

internal sealed class NYSESplit
{
    [JsonPropertyName("exDate")]
    public string ExDate { get; set; } = "";

    [JsonPropertyName("splitFrom")]
    public decimal SplitFrom { get; set; }

    [JsonPropertyName("splitTo")]
    public decimal SplitTo { get; set; }
}

#endregion
